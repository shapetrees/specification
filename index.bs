<pre class="metadata">
Title: Shape Trees Specification
Shortname: shapetrees-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://shapetrees.org/TR/specification/
Editor: Eric Prud'hommeaux
Editor: Justin Bingham
Markup Shorthands: markdown yes
Abstract:
    Semantic Web Applications interoperate by sharing semantics of terms and
    constellations of resource-oriented data structures. This specification
    defines shape trees, a mechanism for declaring and operating over
    constellations of resource-oriented data structures.
</pre>

<!-- For bikeshed style overrides -->
<style>

  em.rfc2119 {
    text-transform: lowercase;
    font-variant: small-caps;
    font-style: normal;
    font-size: 18px;
    color: #900;
  }

  figcaption {
    text-align: left;
  }

  pre {
    font-size: 12px;
  }

  a[href*=".ttl"] {
    color: #339966;
    border-bottom: 1px solid #339966;
  }

  a[href*=".shex"] {
    color: #cc2900;
    border-bottom: 1px solid #cc2900;
  }

  a[href*=".tree"] {
    color: #e68a00;
    border-bottom: 1px solid #e68a00;
  }

  a[data-link-type=dfn] {
    color: #000000;
  }

  table.tree thead tr {
    font-size: 14px;
  }
  
  table.tree tbody tr:nth-child(even) {
    background-color: lightgray;
    font-size: 14px;
  }
  
  table.tree tbody td {
    font-size: 12px;
  }

  table.operation {
    border-collapse: separate;
    border: 3px solid #808080;
    margin-bottom: .5em;
  }

  table.operation thead tr {
    font-size: 14px;
  }

  table.operation thead th {
    background-color: #005A9C;
    color: #FFF;
  }

  table.operation th[colspan] {
    text-align: left;
  }

  table.operation td[colspan] {
    text-align: left;
  }

  table.operation tbody td {
    font-size: 13px;
    text-align: left;
  }

  table.operation code {
    background-color: #DCDCDC;
    color: #000;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;  
  }

  .opdetails code {
    background-color: #DCDCDC; 
    color: #000;
    font-weight: bold;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;
  }

  .opdetails code.vocab {
    color: #339966;
    background-color: #FFFFFF;
  }

  .opdetails ol {
    margin-left: 0;
    padding-left: 1em;
  }

	code.container {
		color: #005555;
	}

	code.notes {
		color: #770033;
	}

	code.citation {
		color: #330077;
	}

	code.image {
		color: #337700;
	}

    code.vocab {
		color: #339966;
	}
</style>

<div boilerplate="copyright">
  <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2020
  <a href="https://www.w3.org/">W3C</a>®
  (<a href="https://www.csail.mit.edu/">MIT</a>,
   <a href="https://www.ercim.eu/">ERCIM</a>,
   <a href="https://www.keio.ac.jp/">Keio</a>,
   <a href="https://ev.buaa.edu.cn/">Beihang</a>).
   W3C
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
   <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a>
   rules apply.
</div>

Introduction {#introduction}
=====================

*This section is non-normative.*

Realizing the value proposition of the Semantic Web lies in building useful and
robust applications that can interoperate over linked data. Protocols such as
[[LDP]] and [[Solid]] organize linked data graphs into resource hierarchies,
providing a foundation upon which these robust and interoperable applications
can be created.

Application interoperability depends on applications sharing semantics for
relationships and data structures.  Existing technologies fulfill portions
of those dependencies:
* [[RDF]]&apos;s foundation in unambiguous identifiers provides an infrastructure
    that allows for interoperability, but does not specifically encourage or enforce it.
* [=Shape=] languages (e.g. [[ShEx]] and [[SHACL]]) provide machine-readable,
    enforceable data structure definitions on single resources.

For applications that operate on more complex and interconnected resources,
<i>[=Shape Trees=]</i> express the layout of those resources and associate them
with their respective [=shapes=].

[=Shape trees=] marry [[RDF]] vocabularies, shapes, and resources into
"little trees" that provide machine to machine interoperability, combining them
into concepts that humans can easily comprehend, such as medical records, notes,
notebooks, calendars, and financial records.

This allows one to treat a set of related resources as a single grouping, and
apply that to a range of operations including access control, data organization,
data validation, and data migration.

While [=shape trees=] are intended to adapt to different technology platforms
that support the notion of [=containers=] and [=resources=], examples in this
specification will reflect usage in an [[LDP]] environment.

[=Shape trees=] are defined as an [=RDF=] graph structure that expresses a set
of expected behaviors by agents that work with them. This provides a sort of
type-safety of resource hierarchies called <dfn>shape tree consistency</dfn>.
These semantics CAN be implemented by a [=server-side agent=], or by a
[=client-side agent=] that implements [=shape tree=] operations as primitive
requests to a server.

[=Shape tree=] support by a [=server-side agent=] ensures [=shape tree
consistency=] by managing all manipulations of data within a resource hierarchy
(see [=managed resource=]).

## ShapeTree Support From Proxy or Client-side Library

If a server does not support [=shape trees=], some [=shape tree consistency=]
can be achieved by implementing [=shape tree=] support in the client, typically
in a library than can enforce consistency for any clients using the
library. Primitive operations by other clients not using the library may leave the
resource hierarchy in an inconsistent state.

For client-side shape tree libraries that operate by intercepting HTTP
operations, this specification serves as an API for those client
interactions. (Additionally, if [=shape tree=] support is later added to the
server, the client's execution of [=shape tree=] operations does not change.) In
the remainder of this document, [=shape tree=] operations are described in terms
of a [=client-side agent=] performing operations on a [=server-side agent=] with
support for [=shape trees=].

A proxy performing [=shape tree=] operations would be indistinguishable from
server support except that clients performing primitive operations directly on
the server (bypassing the proxy) may leave the server in an inconsistent state.

Shape Tree {#tree}
=====================

A <dfn>shape tree</dfn> is a machine-readable template describing the 
expected layout of a tree of resources in a [=container=]-based [=ecosystem=].
A [=shape tree=] expresses a tree hierarchy by containing
other [=shape trees=]. The terms used to express a [=shape tree=] are described 
using an [[RDF]] [vocabulary](shapetree.ttl).

A <dfn>shape tree instance</dfn> is a resource or set of resources assigned to 
and in conformance with a given [=shape tree=]. A resource in a
[=shape tree instance=] is called a <dfn>managed resource</dfn>.

Every [=managed resource=] has an associated [=shape tree locator=].
A [=shape tree locator=] identifies the [=shape tree=] associated
with a [=managed resource=], and additional information needed to navigate 
nested hierarchies of managed resources. A resource becomes a 
[=managed resource=] when a [=shape tree locator=] is associated with it 
through the [[#plant-shapetree]] operation.

The <code class="vocab">st:expectsType</code> property specifies that the 
described [=managed resource=] be one of these three types:

<table class="data" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <tbody>
    <tr>
      <td><code class="vocab">st:Resource</code></td>
      <td>Regular RDF resource that is not a container</td>
    </tr>
    <tr>
      <td><code class="vocab">st:Container</code></td>
      <td>RDF resource that uses server-managed metadata to
      enumerate nested resources</td>
    </tr>
    <tr>
      <td><code class="vocab">st:NonRDFResource</code></td>
      <td>Non-RDF resource such as binaries or images</td>
    </tr>
  </tbody>
</table>

The <code class="vocab">st:shape</code> property specifies that the 
described [=managed resource=] conforms to the stated [[ShEx]] or [[SHACL]] 
shape.

[=Shape trees=] prescribe physical hierarchies and can reference other
shape trees to form virtual hierarchies. 

For physical hierarchies, the <code class="vocab">st:contains</code>
property asserts that a [=managed resource=] is a [=container=] that
explicitly contains another [=managed resource=].

If [=shape tree=] `S1` <code class="vocab">st:contains</code> [=shape tree=] 
`S2`, `S1` describes a [=container=] that contains another [=managed resource=] 
described by `S2`. For example, in [[LDP]], `S1` describes 
an [[LDP]] [=container=] which <code class="vocab">ldp:contains</code> nested 
resources described by `S2`. [=Shape tree=] `S2` and the nested resources 
associated with it are considered to be <dfn>in-scope</dfn> of the containing 
[=shape tree=] `S1`.

The <code class="vocab">st:alsoAllow</code> property in a containing [=shape
tree=] identifies unmanaged resource types permitted beyond those
[=in-scope=]:

<table class="data" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <tbody>
    <tr>
      <td><code class="vocab">st:AllowOnly</code></td>
      <td>Don't allow anything else when no [=shape trees=] are 
      found [=in-scope=]</td>
    </tr>
    <tr>
      <td><code class="vocab">st:AllowAll</code></td>
      <td>Allow all types of unexpected content when no [=shape trees=] 
      are found [=in-scope=]</td>
    </tr>
    <tr>
      <td><code class="vocab">st:AllowResources</code></td>
      <td>Allow if the requested content is a 
        <code class="vocab">st:Resource</code> when no [=shape trees=] 
        are found [=in-scope=]</td>
    </tr>
    <tr>
      <td><code class="vocab">st:AllowContainers</code></td>
      <td>Allow if the proposed content is a 
        <code class="vocab">st:Container</code> when no matching 
        [=shape trees=] are found [=in-scope=]</td>
    </tr>
    <tr>
      <td><code class="vocab">st:AllowNonRDFResources</code></td>
        <td>Allow if the proposed content is a 
        <code class="vocab">st:NonRDFResource</code> when no 
        [=shape trees=] are found [=in-scope=]</td>
    </tr>
  </tbody>
</table>

<figure id="shapetree-physical">
  <figcaption>Shape tree validation of a physical hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1/`</td>
        <td>`ex:ProjectTree`</td>
      </tr>
      <tr>
        <td>`-- /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
      </tr>
      <tr>
        <td>`---- /task-43/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /task-48/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-aa89`</td>
        <td>`ex:AttachmentTree`</td>
      </tr>
      <tr>
        <td>`---- /task-61/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-cd12`</td>
        <td>`ex:AttachmentTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-ef55`</td>
        <td>`ex:AttachmentTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
    </tbody>
  </table>
  
  <pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX ex: &lt;http://www.example.com/ns/ex#&gt;

    <#ProjectTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:ProjectShape ;
      st:contains <#MilestoneTree> ,
                  st:AllowOnly .

    <#MilestoneTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:MilestoneShape ;
      st:contains <#TaskTree>, <#IssueTree> ; 
      st:AllowOnly .

    <#TaskTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:TaskShape ;
      st:contains <#AttachmentTree> ,
      st:AllowOnly .

    <#IssueTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:IssueShape ;
      st:contains <#AttachmentTree> ,
      st:AllowOnly .

    <#AttachmentTree>
      a st:ShapeTree ;
      st:expectsType st:NonRDFResource .
  </pre>

</figure>

A virtual hierarchy is defined by [=shape tree references=] that link to
other [=shape trees=] by the <code class="vocab">st:references</code>
property.
A <dfn>shape tree reference</dfn> 
identifies the [=shape tree=] to be referenced via 
<code class="vocab">st:hasShapeTree</code>, and the [=shape path=] through 
which it is linked via <code class="vocab">st:viaShapePath</code>. 

A <dfn>shape path</dfn> is a string that defines a traversal 
of a [=shape=] schema. [[SHEXPATH]]

<figure id="shapetree-virtual">
  <figcaption>Shape tree validation of a virtual hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1`</td>
        <td>`ex:VirtualProjectTree`</td>
      </tr>
      <tr>
        <td>`/milestone-A`</td>
        <td>`ex:VirtualMilestoneTree`</td>
      </tr>
      <tr>
        <td>`/task-43`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/task-48`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/attachment-aa89`</td>
        <td>`ex:VirtualAttachmentTree`</td>
      </tr>
      <tr>
        <td>`/task-61`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/issue-22`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
      <tr>
        <td>`/attachment-cd12`</td>
        <td>`ex:VirtualAttachmentTree`</td>
      </tr>
      <tr>
        <td>`/attachment-ef55`</td>
        <td>`ex:VirtualAttachmentTree`</td>
      </tr>
      <tr>
        <td>`/issue-31`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
    </tbody>
  </table>

  <pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX ex: &lt;http://www.example.com/ns/ex#&gt;

    <#VirtualProjectTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:ProjectShape ;
      st:references [
        st:hasShapeTree <#VirtualMilestoneTree> ;
        st:viaShapePath "@ex:ProjectShape.ex:hasMilestone"
      ] .

    <#VirtualMilestoneTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:MilestoneShape ;
      st:references [
        st:hasShapeTree <#VirtualTaskTree> ;
        st:viaShapePath "@ex:MilestoneShape.ex:hasTask"
      ] ,
      [
        st:hasShapeTree <#VirtualIssueTree> ;
        st:viaShapePath "@ex:IssueShape.ex:hasIssue"
      ] .

    <#VirtualTaskTree>
      a st:ShapeTree ;
      st:expectsType st:Resource ;
      st:shape ex:TaskShape ;
      st:references [
        st:hasShapeTree <#VirtualAttachmentTree> ;
        st:viaShapePath "@ex:AttachmentShape.ex:hasAttachment"
      ] .

    <#VirtualIssueTree>
      a st:ShapeTree ;
      st:expectsType st:Container ;
      st:shape ex:IssueShape ;
      st:references [
        st:hasShapeTree <#VirtualAttachmentTree> ;
        st:viaShapePath "@ex:AttachmentShape.ex:hasAttachment"
      ] .

    <#VirtualAttachmentTree>
      a st:ShapeTree ;
      st:expectsType st:NonRDFResource .
  </pre>

</figure>

Let <code>ST</code> be a [=shape tree=]. 
Let <code>STI</code> be a corresponding [=shape tree instance=].

* An { `ST` <code class="vocab">st:expectsType</code> `T` } [=triple=] identifies
    the resource type `T` of a  corresponding [=managed resource=] 
    <code>R</code> in <code>STI</code> 
    where `T` <em class="rfc2119">MUST</em> be one of
    <code class="vocab">st:Resource</code>,
    <code class="vocab">st:Container</code>, or
    <code class="vocab">st:NonRDFResource</code>.
* An { `ST` <code class="vocab">rdfs:label</code> `L` } [=triple=]
    indicates that there is at most one corresponding [=managed resource=] 
    `R` in `STI` and it has the name `L`. `L` is a <dfn>static resource</dfn>.

Issue: Do we want a notion for [=static resources=]? 
[Related Issue](https://github.com/shapetrees/specification/issues/47)

* An { `ST` <code class="vocab">st:shape</code> `SH` }
    [=triple=] indicates that [=managed resource=] `R` has
    at most one node which conforms to [=shape=] `SH`.
* An { `ST` <code class="vocab">st:contains</code> `ST2` }
    [=triple=] identifies a nested [=shape tree=] `ST2`.
* An { `ST` <code class="vocab">st:alsoAllow</code> `OP` } [=triple=] identifies
    unmanaged resources types permitted beyond those [=in-scope=] in a managed 
    container  `ST`.
* An { `ST` <code class="vocab">st:references</code> `STR` }
    [=triple=] indicates that the [=shape tree=] identified in
    [=shape tree reference=] `STR`, is referenced through the
    instance data of `STI`.
    * An { `STR` <code class="vocab">st:hasShapeTree</code> `ST3` } [=triple=]
        indicates a [=shape tree=] referenced through the instance data of `STI`
    * An { `STR` <code class="vocab">st:viaShapePath</code> `SHPH` } 
        [=triple=] identifies the [=shape path=] through which a
        [=shape tree instance=] of `ST3` can be found via the instance data of
        `STI`
* An { `ST` <code class="vocab">st:supports</code> `ST4` }
    [=triple=] indicates that `ST` provides supporting or supplementary
    context to `ST4`.

A { `ST` <code class="vocab">st:hasShapeTreeDecoratorIndex</code> `DI` }
    [=triple=] indicates the location of an index of [SKOS hierarchies](#skos-graph)
    that describes `ST`.

## Shape Tree Schema ## {#st-schema}

<figure id="shapetree-shex">
  <figcaption>ShEx Schema for a Shape Tree</figcaption>
	<pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
    PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
    
    <#ShapeTree> {
      a st:ShapeTree ;
      (
        st:expectsType [st:Container] ;
        st:contains @<#ShapeTree> + ;
        ( st:alsoAllow st:AllowAll? |
        st:alsoAllow [ st:AllowResources st:AllowContainers st:AllowNonRDFSources st:AllowOnly ]* )
        |
        st:expectsType [st:Resource st:NonRDFResource]
      ) ;
      rdfs:label xsd:string ? ;
      st:references @<#ReferencedShapeTree> * ;
      st:shape IRI ? ;
      st:contains IRI ? ;
      st:supports IRI ? ;
    }
    
    <#ReferencedShapeTree> {
      st:hasShapeTree IRI ;
      st:viaShapePath xsd:string
    }
	</pre>
</figure>

Shape Tree Locator {#locator}
=====================

A <dfn>shape tree locator</dfn> associates a [=managed resource=] with 
one or more [=shape trees=]. No more than one [=shape tree locator=] may be
associated with a [=managed resource=]. 

For example, in [[Solid]] a [=shape tree locator=] would be stored in an
[auxiliary resource](https://solidproject.org/TR/protocol#auxiliary-resources) 
associated with a given [=managed resource=].

A [=shape tree locator=] includes one or more [=shape tree locations=] via
<code class="vocab">st:location</code>. Each <dfn>shape tree location</dfn> 
identifies a [=shape tree=] 
associated with the [=managed resource=], the focus node for [=shape=] 
validation, and the information 
needed to navigate the physical hierarchy in which that [=managed resource=]
resides.

If there is more than one [=shape tree location=], they all apply to the
[=managed resource=] associated with the [=shape tree locator=].

[=Shape tree locations=] identify key contextual points in a physical hierarchy:

* A <dfn>root shape tree</dfn> marks the primary, or parent [=shape tree=]
    in a physical hierarchy, and is set by the 
    [Plant Operation](#plant-shapetree).

* A <dfn>root shape tree instance</dfn> marks the primary, or parent 
    [=shape tree instance=] in a physical hierarchy, and is set by the
    [Plant Operation](#plant-shapetree).

<figure id="shapetree-location-properties">
  <figcaption>Shape Tree Location properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:hasShapeTree</code></td>
        <td>Identifies the [=shape tree=] to be associated with 
        the [=managed resource=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:node</code></td>
        <td>Identifies the focus node for [=shape=] validation 
        in the associated [=managed resource=], and is only valid when the 
        corresponding [=shape tree=] includes 
        <code class="vocab">st:shape</code></td>
      </tr>    
      <tr>
        <td><code class="vocab">st:shape</code></td>
        <td>Identifies the [=shape=] to which <code class="vocab">st:node</code> 
        must conform</td>
      </tr>
      <tr>
        <td><code class="vocab">st:hasRootShapeTree</code></td>
        <td>Identifies the [=root shape tree=]</td>
      </tr>    
      <tr>
        <td><code class="vocab">st:hasRootShapeTreeInstance</code></td>
        <td>Identifies the [=root shape tree instance=]</td>
      </tr>
    </tbody>
  </table>
</figure>
  
A [=root shape tree=], and its corresponding [=root shape tree instance=] can
be planted within an existing managed hierarchy, alongside or within other
[=root shape trees=] and [=root shape tree instances=].

[=Shape tree locations=]
in a given [=shape tree locator=] may have different
focus nodes.

<figure id="shapetree-navigation">
  <figcaption>Navigating a physical shape tree hierarchy</figcaption>
  <table class="data tree" align="left">
    <colgroup>
    <colgroup>
    <col>
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Shape Tree</th>
        <th>Shape Tree Root</th>
        <th>Shape Tree Instance Root</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/`</td>
        <td>`ex:DataTree`</td>
        <td>`ex:DataTree`</td>
        <td>`/data/`</td>
      </tr>
      <tr>
        <td>`-- /projects/`</td>
        <td>`ex:DataCollectionTree`<br/>
            `ex:ProjectsTree`</td>
        <td>`ex:DataTree`<br/>
            `ex:ProjectsTree`</td>
        <td>`/data/`<br/>
            `/data/projects/`</td>
      </tr>
      <tr>
        <td>`---- /project-1/`</td>
        <td>`ex:ProjectTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`------ /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-43/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-48/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-aa89`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-61/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-cd12`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-ef55`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectsTree`</td>
        <td>`/data/projects/`</td>
      </tr>
    </tbody>
  </table>
</figure>

<figure id="locator-multiple-locations">
  <figcaption>[=Shape Tree Locator=] for /data/projects with multiple 
    [=shape tree locations=] in a nested physical hierarchy</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location [
      st:hasRootShapeTree ex:DataTree ;
      st:hasShapeTree ex:DataTypeTree ;
      st:hasRootShapeTreeInstance &lt;https://storage.example/data/&gt; ;
      st:node &lt;https://storage.example/data/projects#collection&gt; ;
      st:shape ex:DataCollectionShape ;
    ], [
      st:hasRootShapeTree ex:ProjectsTree ;
      st:hasShapeTree ex:ProjectsTree ;
      st:hasRootShapeTreeInstance &lt;https://storage.example/data/projects/&gt; ;
      st:node &lt;https://storage.example/data/projects#collection&gt; ;
      st:shape ex:ProjectCollectionShape ;
    ] .
  </pre>

</figure>

<figure id="locator-single">
  <figcaption>[=Shape Tree Locator=] for 
    /data/projects/project-1/milestone-A/task-48 with a single 
    [=shape tree location=] in a nested physical hierarchy</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location [
      st:hasRootShapeTree ex:ProjectsTree ;
      st:hasShapeTree ex:TaskTree ;
      st:hasRootShapeTreeInstance &lt;https://storage.example/data/projects/&gt; ;
      st:node &lt;https://storage.example/data/projects/project-1/milestone-A/task-48#task&gt; ;
      st:shape ex:ProjectCollectionShape ;
    ] .
  </pre>

</figure>

A [=shape tree location=] may be used to provide shape validation only,
in which case only the focus node and shape are provided, via 
<code class="vocab">st:node</code> and 
<code class="vocab">st:shape</code>, respectively. 

<figure id="shapetree-navigation-shapeonly">
  <figcaption>A [=shape tree locator=] providing only 
  shape validation</figcaption>
  <table class="data tree" align="left">
    <colgroup>
    <colgroup>
    <col>
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Shape</th>
        <th>Focus Node</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/projects/project-1`</td>
        <td>`ex:ProjectShape`</td>
        <td>`/data/projects/project-1#project`</td>
      </tr>
    </tbody>
  </table>
</figure>

<pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;
  PREFIX project1: &lt;https://storage.example/data/projects/project-1#&gt;
  
  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location [
      st:node &lt;https://storage.example/data/projects/project-1#project&gt; ;
      st:shape ex:ProjectShape ;
  ] .
</pre>


## Shape Tree Locator Schema ## {#st-locator-schema}

<figure id="shapetree-locator-shex">
  <figcaption>ShEx Schema for a Shape Tree Locator</figcaption>
	<pre highlight="turtle">
    PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
    PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
    PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
    
    &lt;#ShapeTreeLocatorShape&gt; {
      a [st:ShapeTreeLocator] ;
      st:location @&lt;#ShapeTreeLocationShape&gt;+
    }	
    
    &lt;#ShapeTreeLocationShape&gt; {
      st:hasRootShapeTree IRI ;
      st:hasShapeTree IRI ;
      st:hasRootShapeTreeInstance IRI ;
      ( st:node IRI ;
        st:shape IRI )?
      |
      st:node IRI ;
      st:shape IRI
    }
</pre>
</figure>

Shape Tree Operations {#operations}
=====================

Working with [=shape trees=] entails using several higher-level operations --
each of which may represent one or more HTTP requests and/or pieces of
processing logic.

In regular use, a [=client-side agent=] manipulates resources on a 
[=resource server=] running a [=server-side agent=]. That [=server-side agent=] 
applies logic for [=shape tree=] validation and navigation where applicable
when processing requests from [=client-side agents=]. 

The key operations used to manage [=shape trees=] are:
* [Discover Shape Tree](#discover) - determine the [=shape tree=] linked to some [=managed resource=].
* [Plant Shape Tree](#plant-shapetree) - declare that a resource will henceforth be managed by the provided [=shape tree=].
* [Create Shape Tree Instance](#create-shape-tree-instance) - add a resource to a managed resource hierarchy.
* [Update Shape Tree Instance](#update-shape-tree-instance) - modify a resource in a managed resource hierarchy.
* [Delete Shape Tree Instance](#delete-shape-tree-instance) - remove a resource in a managed resource hierarchy.
* [Unplant Shape Tree](#unplant-shapetree) - assert that a managed resource should no longer be managed by the provided [=shape tree=].

These operations make use of reusable, internal algorithms defined in
[Shape Tree Algorithms](#algorithms).

Note: [=Shape tree=] logic can be applied by [=server-side agents=]
implementing different protocols such as [[LDP]] or [[Solid]]. The operations
defined herein defer to the implementing protocol as to the appropriate
status code and composition of HTTP responses.

## Discover Shape Tree ## {#discover}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation is used by a [=client-side agent=] to discover  
        any [=shape trees=] associated with a given [=resource=].
        
        If `URI` is a [=managed resource=], the associated 
        [=Shape Tree Locator=] will be returned.  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCEURI`</td>
      <td>The URI of the resource to discover shape trees for</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATOR`</td>
      <td>[=Shape tree locator=] associated with the [=managed resource=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP HEAD or GET on the provided <code>RESOURCEURI</code>.  

<pre highlight="http">
  HEAD https://storage.example/data/projects/
</pre>

<pre highlight="http">
  HTTP/1.1 200 OK
  Link: &lt;https://storage.example/meta/c560224b#locator&gt;; rel="http://www.w3.org/ns/shapetrees#ShapeTreeLocator"
  Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
  ...other HTTP response headers omitted...
</pre>

2. Let <code>LOCATORURI</code> be the URI of a [=shape tree locator=] 
    associated with `RESOURCEURI` with a relation type of 
    `http://www.w3.org/ns/shapetrees#ShapeTreeLocator`. Depending upon the implementing
    protocol, this relation may be discovered in an HTTP Link header, or in
    the HTTP response body. 
   
3. If `LOCATORURI` is empty, the resource at 
    `RESOURCEURI` is not a [=managed resource=], and no [=shape tree locator=] 
    will be returned.
   
4. Perform an HTTP GET on `LOCATORURI`

<pre highlight="http">
  GET https://storage.example/meta/c560224b#locator
</pre>

<pre highlight="turtle">
  ...HTTP response headers omitted...
  PREFIX st: &lthttp://www.w3.org/ns/shapetrees#&gt;
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt; st:hasShapeTreeLocator &lt;#locator&gt; .

  &lt;#locator&gt;
    a st:ShapeTreeLocator ;
    st:location [
      st:hasRootShapeTree ex:DataTree ;
      st:hasShapeTree ex:DataTypeTree ;
      st:hasRootShapeTreeInstance &lt;https://storage.example/data/&gt; ;
      st:node &lt;https://storage.example/data/projects#collection&gt; ;
      st:shape ex:DataCollectionShape ;
    ], [
      st:hasRootShapeTree ex:ProjectsTree ;
      st:hasShapeTree ex:ProjectsTree ;
      st:hasRootShapeTreeInstance &lt;https://storage.example/data/projects/> ;
      st:node &lt;https://storage.example/data/projects#collection> ;
      st:shape ex:ProjectCollectionShape ;
    ] .
</pre>

5. If a corresponding resource at `LOCATORURI` cannot be found, it 
    <em class="rfc2119">MUST</em> be considered
    an [=unmanaged resource=].

<pre highlight="http">
GET https://storage.example/meta/c560224b#locator
</pre>

<pre highlight="http">
HTTP/1.1 404 NOT FOUND
</pre>

5. If `LOCATORURI` is a valid [=shape tree locator=],
    the resource at `RESOURCEURI` <em class="rfc2119">MUST</em> be considered a 
    [=managed resource=].

</div>

## Plant Shape Tree ## {#plant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation marks an existing [=resource=] as being managed by 
        one or more shape trees, by associating a [=shape tree locator=] with the
        resource, and turning it into a [=managed resource=]. 

        If the 
        [=resource=] is already managed, the associated [=shape tree locator=]
        will be updated with another [=shape tree location=] for the 
        planted [=shape tree=].

        If the [=resource=] is a container that already contains existing
        resources, and a recursive plant is requested, this operation will
        perform a depth first traversal through the containment
        hierarchy, validating and assigning as it works its way back up to
        the target root resource of this operation.

        Note: Whether a recursive plant operation should be supported is 
        currently under debate. 
        [Related Issue](https://github.com/shapetrees/specification/issues)

      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#plant-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the resource to plant on</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the shape tree to plant for `TR`</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>A <em class="rfc2119">OPTIONAL</em> URI representing the target 
      subject within `TR` used for shape validation</td>
    </tr>
    <tr>
      <td>`RECURSIVE`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> boolean flag that is FALSE
      by default. When TRUE, it specifies a recursive plant over a
      physical hierarchy of **already existing** resources</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATORURI`</td>
      <td>An HTTP response containing a Location header with the URI of the 
        [=Shape Tree Locator=] that `TST` was planted in</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. [Discover](#discover) if `TR` is a [=managed resource=]. 
    * Let `LOCATORURI` be the URI of the [=Shape Tree Locator=] associated 
        with `TR` if it is [=managed resource=].
1. Perform an HTTP `PUT` or `PATCH` on `LOCATORURI` to create or update the 
    [=Shape Tree Locator=] for `TR`
    * If `TR` is already managed, add a new `st:ShapeTreeLocation` to the
        existing `st:ShapeTreeLocator`
    * If `TR` is not already managed, create a new  
        `st:ShapeTreeLocator`, with a corresponding 
        `st:ShapeTreeLocation LN`
    * Let `LN hasShapeTree` be `TST`
    * Let `LN hasRootShapeTree` be `TST`
    * Let `LN hasRootShapeTreeInstance` be `TR`
    * If `TST` has an `st:shape`
        * Let `LN st:shape` be the object value of `TST st:shape`
        * Let `LN st:node` be `FN`

</div>

### [=Server-side Agent|Server-side=] ### {#plant-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `PUT` or `PATCH` request on `LOCATORURI` from the 
    [[#plant-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATORURI`</td>
      <td>An HTTP response containing a Location header with the URI of the 
        planted [=Shape Tree Locator=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

Note: The following sequence is invoked by the server in response 
to the `HTTP PUT` on `LOCATORURI` by the [=client-side agent=] in the 
[[#plant-client|previous sequence]].

1. Proceed if `REQ` contains an `HTTP Link` header with a relation of 
    `http://shapetrees.org/#PlantShapeTree`
1. If `REQ` attempts to alter an existing [=shape tree location=], the server
    <em class="rfc2119">MUST</em> return `409 Conflict`
1. Let `LOCATORURI` be the target URI of `REQ`
1. Let `TR` be the target [=resource=] directly associated with `LOCATORURI`
1. Let `PC` be the parent [=container=] of `TR`
1. Let `PCST` be the [=shape tree=] associated with `PC` with an `st:contains` value
1. Let `RECURSIVE` be `FALSE` unless `REQ` contains an `HTTP Link` header with a relation of
    `http://shapetrees.org/#PlantShapeTreeRecursive`
1. For each new [=Shape Tree Location=] `LN` in `REQ`
    1. Let `TST` be the target [=shape tree=] `LN st:hasShapeTree` to plant for `TR`
    1. Let `FN` be an optional focus node for validation `LN st:node`  
    1. If `TR` is a [=container=] call [[#assign-container]] with inputs:
        * `TR` - target [=container=] for the plant operation
        * `ST` - target [=shape tree=] to plant at `R`
        * `FN` - optional [=focus node=] to use when `ST st:shape` is set
        * `PC` - parent [=container=] of `R`
        * `PCST` - [=shape tree=] associated with `PC` with `st:contains`
        * `LN st:hasRootShapeTree` - [=root shape tree=] provided by client
        * `LN st:hasRootShapeTreeInstance` - [=root shape tree instance=] provided by client
        * `RECURSIVE` - Boolean indicator to perform a recursive plant operation
    1. If `R` is a non-container [=resource=] call [[#assign-resource]]
        * `R` - target [=resource=] for the plant operation
        * `ST` - target [=shape tree=] to plant at `R`
        * `FN` - optional [=focus node=] to use when `ST st:shape` is set
        * `LN st:hasRootShapeTree` - [=root shape tree=] provided by client
        * `LN st:hasRootShapeTreeInstance` - [=root shape tree instance=] provided by client
1. Return `LOCATORURI` in the `HTTP Location` header

</div>

## Unplant Shape Tree ## {#unplant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation unassigns a planted 
        [=root shape tree=] from a [=root shape tree instance=]. If the
        [=root shape tree instance=] is a [=managed container=], it will also
        unassign contained resources.
        
        If there are no remaining [=shape trees=]
        managing the [=resource=], it would no longer be considered as managed.
      </td>
  </tbody>
</table>

### [=Client-side Agent|Client-side=] ### {#unplant-client}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=managed resource=] to unplant</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the target shape tree to unplant for `TR`</td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=Shape Tree Locator=] returned from [[#discover]] 
    with inputs: `TR`

1. Return `422 Unprocessable Entity` if `LOCATOR` has zero or more than one
    [=shape tree locations=] where `st:hasShapeTree` is `TST`
   
1. If `LOCATOR` has a single [=shape tree location=]
    1. Perform an HTTP `DELETE` on `LOCATOR` to fully remove the
        [=Shape Tree Locator=] for `TR`

1. If `LOCATOR` has more than one [=shape tree location=]
    1. Let `LN` be the [=shape tree location=] where `st:hasShapeTree` is `TST`
    1. Perform an HTTP `PUT` or `PATCH` on `LOCATOR` to remove `LN`

</div>

### [=Server-side Agent|Server-side=] ### {#unplant-server}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>
        An HTTP PUT, PATCH, or DELETE request on the [=shape tree locator=]
        `LOCATOR` from the [[#unplant-client|previous sequence]].
      </td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=shape tree locator=] associated with `TR`
1. Let `LN` be the [=shape tree location=] associated with `TR` where:
    * `LN st:hasShapeTree` is `TST`
    * `LN st:hasShapeTreeRoot` is `ROOTST`
    * `LN st:hasShapeTreeRootInstance` is `ROOTSTI`
1. If `LOCATOR` or `LN` are empty <em class="rfc2119">MUST</em> return 
    `404 Not Found`

1. If `TR` is a [=container=]
    1. Call [[#unassign-container]] with inputs:
        * `TR` - Target Container
        * `TST` - Target Shape Tree to unassign
        * `ROOTST` - Root Shape Tree to unplant
        * `ROOTSTI` - Root Shape Tree instance to unplant
1. If `TR` is a non-container [=resource=]
    1. Call [[#unassign-resource]] with inputs:
        * `TR` - Target Resource
        * `TST` - Target Shape Tree to unassign
        * `ROOTST` - Root Shape Tree to unplant
        * `ROOTSTI` - Root Shape Tree instance to unplant

</div>

## Create Shape Tree Instance ## {#create-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation creates a [=shape tree instance=] within a 
        [=managed container=]. 

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#create-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target shape 
      tree associated with the created resource</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target 
      subject within `TR` used for shape validation</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `POST` or `PUT` on `TR` to create the
    [=shape tree instance=] including:
    * An HTTP `Link` header with the relation of 
        `http://shapetrees.org/#targetShapeTree` if `SHAPETREEURI` is provided
    * An HTTP `Link` header with the relation of 
        `http://shapetrees.org/#focusNode` if `FNURI` is provided

</div>

### [=Server-side Agent|Server-side=] ### {#create-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `POST` or `PUT` request on the [=managed container=] `MC` 
      from the [[#create-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the proposed resource from `REQ`
1. Let `PC` be the URI of the target [=container=]
1. Let `LR` be the URI of a [=shape tree locator=] [discovered](#discover) for `PC`    
1. Let `PCST` be the URI of a [=shape tree=] with `st:contains` in `LR`
1. If `PCST` exists
    1. Let `TST` be the target [=shape tree=] URI from an HTTP `Link` header with a
        relation of `http://shapetrees.org/#targetShapeTree`
    1. Let `FN` be a focus node URI from an HTTP `Link` header with a relation of
        `http://shapetrees.org/#focusNode`
    1. Let `ROOTST` and `ROOTSTI` be the [=root shape tree=] and 
        [=root shape tree instance=] associated with the [=Shape Tree Location=]
        for `PCST`
    1. Let `TSTMATCH` be the return value of [[#matching-contained-shapetree]]
        with inputs: `PC`, `TR`, `TST`, `FN`. `TSTMATCH` is an
         [=RDF graph=] containing:
             * `st:hasShapeTree` - matched [=shape tree=] in `PC st:contains`
             * `st:shape` - matching shape (if applicable)
             * `st:node` - focus node of shape match (if applicable)
    1. If `TSTMATCH` is not `NULL`
        1. Call [[#check-resource]] with inputs: `TR`, 
            `TSTMATCH st:HasShapeTree`, `TSTMATCH st:node` 
1. Create [=resource=] `TR`
1. If `PCST` exists 
    1. Call [[#assign-resource]] with inputs:
        * `TR` - created [=resource=]
        * `TST` - target [=shape tree=]
        * `FN` - [=focus node=]
        * `PC` - URI of the target parent [=container=]
        * `PCST` - Containing shape tree associated with `PC`  
        * `ROOTST` - [=root shape tree=] is always set by the called function
        * `ROOTSTI` - [=root shape tree instance=] is always set by the called function

</div>

## Update Shape Tree Instance ## {#update-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation updates a [=managed resource=] for an existing 
        [=shape tree instance=]. 

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#update-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `PUT` or `PATCH` on an existing resource `TR` to update the
     [=shape tree instance=]
   
</div>

### [=Server-side Agent|Server-side=] ### {#update-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `PUT` or `PATCH` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Let `LR` be the URI of a [=shape tree locator=] [discovered](#discover) for `TR`
1. If `LR` exists
    1. For each [=shape tree location=] `LN` in `LR`
        1. Call [[#check-resource]] with inputs: `TR`,
             `LN st:hasShapeTree`, `LN st:node`
1. Update [=resource=] `TR`

</div>

## Delete Shape Tree Instance ## {#delete-shape-tree-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation deletes a [=managed resource=] for an existing 
        [=shape tree instance=]. 

        Note: This operation should be performed as
        a standard HTTP operation with no knowledge of [=shape trees=]. It
        is included here for completeness
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#delete-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `DELETE` on an existing resource `TR` to delete the
    [=shape tree instance=]

</div>

### [=Server-side Agent|Server-side=] ### {#delete-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `DELETE` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Delete [=resource=] `TR`
    * The [=Shape Tree Locator=] associated with `TR`
        <em class="rfc2119">MUST</em> be removed with `TR`

</div>

Shape Tree Algorithms {#algorithms}
=====================

The following algorithms define a library of functions referenced in the above
[operations](#operations).

## Assign Shape Tree to Container ## {#assign-container}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      Assigns the target [=shape tree=] `TST` to the target [=container=] 
      resource `TR`.

      It will perform recursive assignment if the recursive plant option 
      `RECURSIVE` is set. 

      Note: Whether a recursive plant operation should be supported is currently
      under debate. 
      [Related Issue](https://github.com/shapetrees/specification/issues)

      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TC`</td>
      <td>
        The URI of the target [=container=] to plant [=shape tree=] `TST` 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        The URI of an <em class="rfc2119">Optional</em> target [=shape tree=] 
        to plant for `TC` 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">Optional</em> focus node to use for shape 
        validation when `TST st:shape` is set 
      </td>
    </tr>
    <tr>
      <td>`PC`</td>
      <td>
        The parent [=container=] of `TC` 
      </td>
    </tr>
    <tr>
      <td>`PCST`</td>
      <td>
        The [=shape tree=] associated with `PC` with `st:contains` 
      </td>
    </tr>
    <tr>
      <td>`ROOTST`</td>
      <td>
        The [=root shape tree=] for the current physical hierarchy 
      </td>
    </tr>
    <tr>
      <td>`ROOTSTI`</td>
      <td>
        The [=root shape tree instance=] for the current physical hierarchy 
      </td>
    </tr>
    <tr>
      <td>`RECURSIVE`</td>
      <td>
        Boolean indicator to perform a recursive plant operation. 
        Default is `FALSE` 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATIONURI`</td>
      <td>
        The URI of the [=Shape Tree Location=] assigned to `TC`
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Server <em class="rfc2119">MUST</em> return `422 Unprocessable Entity`
    if `RECURSIVE` is `FALSE` and `TC` contains any number of [=resources=]
1. If `TST` is `NULL`: 
    1. Let `TSTMATCH` be the return value of [[#matching-contained-shapetree]] 
        with inputs: `PC`, `TR`, `NULL`, `NULL`. `TSTMATCH` is an
        [=RDF graph=] containing: 
            * `st:hasShapeTree` - matched [=shape tree=] in `PC st:contains`
            * `st:shape` - matching shape (if applicable)
            * `st:node` - focus node of shape match (if applicable)
    1. Return `NULL` if `TSTMATCH` is `NULL`
    1. Let `TST` be `TSTMATCH st:hasShapeTree`
    1. Let `FN` be `TSTMATCH st:node`
1. If `RECURSIVE` is `TRUE`
    1. If `TST st:contains` is set:
        1. For each [=container=] contained in `TC`:
            1. Let `CTC` be the contained target [=container=]
            1. Call [[#assign-container]] with inputs:
                * `CTC` - target [=container=] for assignment
                * `NULL` - called function will set the target [=shape tree=]
                * `NULL` - will not know the focus node for validation at this stage
                * `TC` - parent [=container=] of `CTC`
                * `TST` - [=shape tree=] associated with `TC` with `st:contains`
                * `ROOTST` - [=root shape tree=]
                * `ROOTSTI` - [=root shape tree instance=]
                * `RECURSIVE` - `TRUE`
        1. For each non-container [=resource=] contained in `TC`:
            1. Let `CTR` be the contained target [=resource=]
            1. Call [[#assign-resource]] with inputs:
                 * `CTR` - target [=resource=] for assignment
                 * `NULL` - called function will set the target [=shape tree=]
                 * `NULL` - will not know the focus node for validation at this stage
                 * `TC` - parent [=container=] of `CTR`
                 * `TST` - [=shape tree=] associated with `TC` with `st:contains`
                 * `ROOTST` - [=root shape tree=]
                 * `ROOTSTI` - [=root shape tree instance=]
1. Let `LOCATIONURI` be the [=Shape Tree Location=] returned from 
    [[#assign-resource]] with inputs:
    * `TC` - target [=resource=] for assignment
    * `TST` - called function will set the target [=shape tree=]
    * `FN` - May not know the focus node for validation at this stage
    * `PC` - parent [=container=]
    * `PCST` - [=shape tree=] associated with `TC` with `st:contains`
    * `ROOTST` - [=root shape tree=]
    * `ROOTSTI` - [=root shape tree instance=]
1. Return `LOCATIONURI`

</div>

## Assign Shape Tree to Resource ## {#assign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      Assigns the target [=shape tree=] `TST` to the target [=resource=] 
      resource `TR`. Can be called for both [=container=] and non-container
      resources.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>
        The URI of the target [=resource=] to assign [=shape tree=] `TST` 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        The URI of the target [=shape tree=] to assign for `TR` 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">Optional</em> focus node to use for shape 
        validation when `TST st:shape` is set 
      </td>
    </tr>
    <tr>
      <td>`PC`</td>
      <td>
        The parent [=container=] of `TR` 
      </td>
    </tr>
    <tr>
      <td>`PCST`</td>
      <td>
        The [=shape tree=] associated with `PC` with `st:contains` 
      </td>
    </tr>
    <tr>
      <td>`ROOTST`</td>
      <td>
        The [=root shape tree=] for the current physical hierarchy 
      </td>
    </tr>
    <tr>
      <td>`ROOTSTI`</td>
      <td>
        The [=root shape tree instance=] for the current physical hierarchy 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATIONURI`</td>
      <td>
        The URI of the [=Shape Tree Location=] assigned to `TR`
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=Shape Tree Locator=] directly associated with 
    `TR`, such as by calling [[#discover]].
1. If `TST` is `NULL`:
    1. Let `TSTMATCH` be the return value of [[#matching-contained-shapetree]]
          with inputs: `PC`, `TR`, `NULL`, `NULL`. `TSTMATCH` is an
          [=RDF graph=] containing:
          * `st:hasShapeTree` - matched [=shape tree=] in `PC st:contains`
          * `st:shape` - matching shape (if applicable)
          * `st:node` - focus node of shape match (if applicable)
    1. Return `NULL` if `TSTMATCH` is `NULL`
    1. Let `TST` be `TSTMATCH st:hasShapeTree`
    1. Let `FN` be `TSTMATCH st:node`
1. Call [[#check-resource]] with inputs:
    * `TR` - target [=resource=] to validate
    * `TST` - [=shape tree=] to validate against
    * `FN` - focus node for shape validation
1. Create a new [=Shape Tree Location=] `LN` in `LOCATOR` with properties:
    * `LN st:hasShapeTree` - `TST`
    * `LN st:hasRootShapeTree` - `ROOTST`
    * `LN st:hasRootShapeTreeInstance` - `ROOTSTI`
    * `LN st:node` - `FN`
    * `LN st:shape` - `TST st:shape`
1. return `LN`

</div>

## Unassign Shape Tree from Container ## {#unassign-container}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      Unassigns the target [=shape tree=] `TST` from the target [=container=] 
      resource `TC`. This will perform recursive unassignment.
    </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TC`</td>
      <td>
        The URI of the target [=container=] to unassign [=shape tree=] `TST` 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        The URI of the target [=shape tree=] to unassign for `TC` 
      </td>
    </tr>
    <tr>
      <td>`ROOTST`</td>
      <td>
        The [=root shape tree=] for the current physical hierarchy 
      </td>
    </tr>
    <tr>
      <td>`ROOTSTI`</td>
      <td>
        The [=root shape tree instance=] for the current physical hierarchy 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATIONURI`</td>
      <td>
        The URI of the [=Shape Tree Location=] assigned to `TC`
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=shape tree locator=] associated with `TC`
1. Let `LN` be the [=shape tree location=] associated with `TC` where:
    * `LN st:hasShapeTree` is `TST`
    * `LN st:hasShapeTreeRoot` is `ROOTST`
    * `LN st:hasShapeTreeRootInstance` is `ROOTSTI`
1. Return `NULL` if `LOCATOR` or `LN` are not found
1. If `TST st:contains` is set:
    1. Let `TSTC` be a set of [=shape trees=] linked via `TST st:contains`
    1. For each container `CTC` contained in `TC`
        1. Let `CTCLR` be the [=shape tree locator=] associated with `CTC`
        1. Let `CTCLN` be a location in `CTCLR` with a shape tree in `TSTC`
        1. Continue if `CTCLN` is empty
        1. Call [[#unassign-container]] with inputs: `CTC`, `CTCLN st:hasShapeTree`,
            `ROOTST`, `ROOTSTI`
    1. For each resource `CTR` contained in `TC`
        1. Let `CTRLR` be the [=shape tree locator=] associated with `CTR`
        1. Let `CTRLN` be a location in `CTRLR` a shape tree in `TSTC`
        1. Continue if `CTRLN` is empty
        1. Call [[#unassign-resource]] with inputs: `CTR`, `CTRLN st:hasShapeTree`,
            `ROOTST`, `ROOTSTI`
1. Call [[#unassign-resource]] on `TC` with inputs: `TC`, `TST`, `ROOTST`, `ROOTSTI`

</div>

## Unassign Shape Tree from Resource ## {#unassign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2> 
      Unassigns the target [=shape tree=] `TST` from the target [=resource=] 
      resource `TR`. Can be called for both [=container=] and non-container
      resources.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>
        The URI of the target [=resource=] to unassign [=shape tree=] `TST` from 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        The URI of the target [=shape tree=] to unassign for `TR` 
      </td>
    </tr>
    <tr>
      <td>`ROOTST`</td>
      <td>
        The [=root shape tree=] for the current physical hierarchy 
      </td>
    </tr>
    <tr>
      <td>`ROOTSTI`</td>
      <td>
        The [=root shape tree instance=] for the current physical hierarchy 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATIONURI`</td>
      <td>
        The URI of the [=Shape Tree Location=] unassigned from `TR`
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `LOCATOR` be the [=shape tree locator=] associated with `TC`
1. Let `LN` be the [=shape tree location=] associated with `TC` where:
    * `LN st:hasShapeTree` is `TST`
    * `LN st:hasShapeTreeRoot` is `ROOTST`
    * `LN st:hasShapeTreeRootInstance` is `ROOTSTI`
1. Return `NULL` if `LOCATOR` or `LN` aren't found
1. Remove `LN` from `LOCATOR`
1. Remove `LOCATOR` is there are no remaining [=shape tree locations=]

</div>

## Check Resource Conformance ## {#check-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This algorithm is responsible for determining whether a given resource
      conforms with a given  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>
        The URI of the target [=resource=] to validate 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        The URI of the target [=shape tree=] to validate against `TR` 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">Optional</em> focus node to use for shape 
        validation when `TST st:shape` is set 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`Boolean`</td>
      <td>
        `TRUE` if validation is successful. Returns an HTTP error code
        on failure.
      </td>
    </tr>
  </tbody>
</table>

1. Server <em class="rfc2119">MUST</em> return `422 Unprocessable Entity` if 
    the value of `TST st:expectsType` does not match the resource type of `TR`
1. Server <em class="rfc2119">MUST</em> return `422 Unprocessable Entity` if
    the value of `TST st:shape` is not empty and shape validation of the 
    [=RDF graph=] body of `REQ` fails.
    * If `TST st:node` is not empty, it should be considered as the focus node
        for shape validation. Otherwise, shape validation should be
        evaluated against all subject nodes in the [=RDF graph=] body of `REQ`

## Find Matching Contained Shape Tree ## {#matching-contained-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for determining which [=shape tree=] within a set
        of shape trees mentioned in <code class="vocab">st:contains</code> is
        applicable for a given proposed resource.

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either
            a [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`PC`</td>
      <td>
        The URI of the parent [=managed container=] that will contain the 
        proposed resource
      </td>
    </tr>
    <tr>
      <td>`TR`</td>
      <td>
        The proposed [=resource=] to be stored in `PC`
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI representing the shape 
        tree corresponding with the proposed resource. No other [=shape trees=]
        from `PC` are considered when provided. 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI representing the target 
        subject within `TR` used for shape validation.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`CSTMATCH`</td>
      <td>
        An [=RDF graph=] containing:
        <ul>
          <li>`st:hasShapeTree` - matched [=shape tree=] in `PC st:contains`</li>
          <li>`st:shape` - matching shape (if applicable)</li>
          <li>`st:node` - matching focus node (if applicable)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `MST` be the [=shape trees=] managing `PC` found through [discovery](#discover)
1. Let `CST` be the [=shape tree=] within `MST` with an
    <code class="vocab">st:contains</code> value(s)
1. Let `CSTC` be the [=shape trees=] associated with `CST st:contains`. These
    will be the candidate shape trees that `TR` must match against
1. If `TST` is specified
    1. and `TST` does NOT exist within `CSTC` this
          algorithm <em class="rfc2119">MUST</em> return a 400 status code
    1. and `TST` exists within `CSTC` return an [=RDF graph=] containing:
        * `st:hasShapeTree` - `TST`
        * `st:shape` - `TST st:shape`
        * `st:node` - `FN`
1. If `TST` is not specified, iterate each [=shape tree=] `CSTC-ST` in `CSTC` 
    to determine match:
    1. Continue to the next iteration if the resource type of `TR` is not 
        the same as `CSTC-ST st:expectsType`
    1. Continue to the next iteration if there is no subject node in `TR` that
        successfully validates against `CSTC-ST st:shape`
    1. Return an [=RDF graph=] containing:
        * `st:hasShapeTree` - `CSTC-ST`
        * `st:shape` - `CSTC-ST st:shape`
        * `st:node` - the matching subject node from successful validation of
            `CSTC-ST st:shape`
1. If `CSTC` does not contain any of
    <code class="vocab">st:AllowAll</code>,
    <code class="vocab">st:AllowResources</code>,
    <code class="vocab">st:AllowContainers</code>,
    <code class="vocab">st:AllowNonRDFSources</code>,
    this algorithm <em class="rfc2119">MUST</em> return a status code of 422
1. If <code class="vocab">st:AllowOnly</code> exists within
    `CSTC`, this algorithm <em class="rfc2119">MUST</em>
    return a status code 422
1. If <code class="vocab">st:AllowAll</code> exists within
    `CSTC`, return `NULL` - indicating that while no match was
    found, `PC` has been configured to allow resources of any
    type to be created without matching the shape tree
1. If <code class="vocab">st:AllowResources</code> exists within
    `CSTC`:
    1. And the resource type of `TR` isn't an `st:Resource`,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type of `TR` is a `st:Resource`,
          return `NULL` - indicating that while no match was found,
          `PC` has been configured to allow non-container [=resources=] to be
          created without matching the shape tree
1. If <code class="vocab">st:AllowContainers</code> exists within
    `CSTC`:
    1. And the resource type of `TR` is not an `st:Container`,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type of `TR` is an `st:Container`,
          return `NULL` - indicating that while no match was found,
          `PC` has been configured to allow [=containers=] to be
          created without matching the shape tree
1. If <code class="vocab">st:AllowNonRDFSources</code> exists within
    `CSTC`:
    1. And the resource type of `TR` is not an `st:NonRDFResource`,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type of `TR` is a Non-RDF [=resource=],
          return `NULL` - indicating that while no match was found,
          `PC` has been configured to allow non-RDF resources to
          be created without matching the shape tree

</div>

Describing Shape Trees {#describing}
=====================

While the RDF structure of [=shape trees=] enable machine readability, additional
context is needed to make it human-friendly.

External [=SKOS graphs=] can be <em class="rfc2119">OPTIONALLY</em> linked to
describe the shape tree in human-readable terms.

* Let <code>STR</code> be an RDF document containing one or more
    [=shape trees=] <code>STs</code>.
* The { &lt;&gt; <code class="vocab">st:hasShapeTreeDecoratorIndex</code>
    <code>IDX</code> } [=triple=] indicates that there is exactly one
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> located at
    <code>IDX</code>.
* The { <code>IDX</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> } [=triple=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> that represents an
    index of <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>IDX</code> <code class="vocab">st:hasSet</code>
    <code>SET</code> } [=triple=] indicates linkage to one or more
    <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>SET</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorSet</code> } [=triple=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorSet</code> that represents a
    [=SKOS graphs=] for a given language or interpretation.
* The { <code>SET</code> <code class="vocab">st:hasShapeTreeDecoratorResource</code>
    <code>DECRESOURCE</code> } [=triple=] indicates linkage to a single
    <code class="vocab">st:ShapeTreeDecoratorResource</code>.
* The { <code>SET</code> <code class="vocab">st:usesLanguage</code>
    <code>LANG</code> } [=triple=] indicates the language used by the associated
    <code>DECRESOURCE</code>.

<figure id="shapetree-decorator-shex">
  <figcaption>ShEx validation of a Shape Tree Decorators</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt;
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
  PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
  PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

  &lt;#DecoratorIndex&gt; {
    a [ st:ShapeTreeDecoratorIndex ] ;
    st:defaultLanguage xsd:language ? ;
    st:hasSet IRI*
  }

  &lt;#DecoratorSet&gt; {
    a [ st:ShapeTreeDecoratorSet ] ;
    st:usesLanguage xsd:language ;
    st:hasShapeTreeDecoratorResource IRI
  }

  &lt;#Decorator&gt; {
    a [ st:ShapeTreeDecorator ] ;
    st:hasShapeTree IRI ;
    skos:prefLabel xsd:string ;
    skos:definition xsd:string ?
  }
  
  </pre>
</figure>    

SKOS constructs such as <code>skos:narrower</code> <em class="rfc2119">MAY</em>
  be used to group or organize related [=shape trees=].

Definitions {#definitions}
=====================
Two terms are imported from [[RDF]]:
  * <dfn>triple</dfn> -- an [RDF triple](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
  * <dfn>RDF graph</dfn> -- an [RDF graph](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
        as defined in [[RDF]].

The following terms are used throughout this specification:
  * <dfn>Client-side Agent</dfn> -- A software component interacting with a server.
        A client-side agent will typically rely on the server for shape tree 
        evaluation and/or validation, but may choose to apply it locally
        as well.
  * <dfn>Container</dfn> -- the generalized notion of a collection of resources;
        implementations of [=shape trees=] <em class="rfc2119">MAY</em> use a
        container implementation such as [[LDP]]
        ([ldp:Container](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-container),
        [ldp:BasicContainer](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-basic-container),
        etc.)
  * <dfn>Ecosystem</dfn> -- a software environment with resources organized in
        some hierarchical grouping that rely on [=shape tree=] concepts to
        better organize and validate structures of data
  * <dfn>Focus Node</dfn> -- a node in an [=RDF graph=].  In
        the context of [=shape trees=], one usage is directing [=shape=] validation
        to the appropriate node in an [=RDF graph=].
  * <dfn>Managed Container</dfn> -- any [=managed resource=] that is a 
        [=container=]. A [=Managed Container=] <em class="rfc2119">MAY</em>
        be an [=Instance Root=] or hierarchically nested within the
        resource hierarchy.
  * <dfn>Non-RDF Source</dfn> -- the generalized notion of document not
        containing linked-data triples; this may include
        plain text or binary data.
  * <dfn>Resource</dfn> -- the generalized notion of document containing linked-data;
        implementations of [=shape trees=] may use a resource implementation such
        as [[LDP]] (ldp:Resource, etc.)
  * <dfn>Server-side Agent</dfn> -- A server-side software component.  Server-side
        agents that support shape trees are responsible for data validation and
        maintaining [=shape tree locators=].
  * <dfn>Shape</dfn> -- a schema definition allowing validation of an RDF
        subject.  Example specifications supporting the notion of shapes include 
        [[ShEx]] and [[SHACL]].
  * <dfn>SKOS Graph</dfn> -- an [=RDF graph=] conforming to [[skos-reference]]
        data model.  For purposes of [=shape trees=] a
        [=SKOS Graph=] is used to describe a [=shape tree=] in
        human-readable terms.
  * <dfn>Unmanaged Resource</dfn> -- any [=resource=] which does not have an associated
        [=shape tree=].

  <pre class="biblio">
  {
    "ldp": {
      "href": "https://www.w3.org/TR/ldp/",
      "title": "Linked Data Platform 1.0",
      "authors": [
        "Steve Speicher",
        "John Arwe",
        "Ashok Malhotra"
      ]
    },
    "solid": {
          "href": "https://solidproject.org/TR/protocol",
          "title": "Solid Protocol",
          "authors": [
            "Sarven Capasdisli",
            "Tim Berners-Lee",
            "Kjetil Kjernsmo",
            "Justin Bingham",
            "Ruben Verborgh",
            "Dmitri Zagidulin"]
    },
    "rdf": {
          "href": "https://www.w3.org/TR/rdf11-concepts",
          "title": "RDF 1.1 Concepts and Abstract Syntax",
          "authors": [
            "Richard Cyganiak",
            "David Wood",
            "Markus Lanthaler"
          ]
        },
    "shex": {
      "href": "http://shex.io/shex-semantics/index.html",
      "title": "Shape Expressions Language 2.1",
      "authors": [
        "Eric Prud'hommeaux",
        "Iovka Boneva",
        "Jose Emilio Labra Gayo",
        "Gregg Kellogg"
      ]
    },
    "shexpath": {
      "href": "https://shexspec.github.io/spec/ShExPath",
      "title": "Shape Expressions ShExPath Language",
      "authors": [
        "Eric Prud'hommeaux"
      ]
    }
  }
  </pre>
