<pre class="metadata">
Title: Shape Trees Specification
Shortname: shapetrees-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://shapetrees.org/TR/specification/
Editor: Eric Prud'hommeaux
Editor: Justin Bingham
Markup Shorthands: markdown yes
Abstract:
    Semantic Web Applications interoperate by sharing semantics of terms and
    constellations of resource-oriented data structures. This specification
    defines shape trees, a mechanism for declaring and operating over
    constellations of resource-oriented data structures.
</pre>

<!-- For bikeshed style overrides -->
<style>

  em.rfc2119 {
    text-transform: lowercase;
    font-variant: small-caps;
    font-style: normal;
    font-size: 18px;
    color: #900;
  }

  figcaption {
    text-align: left;
  }

  a[href*=".ttl"] {
    color: #339966;
    border-bottom: 1px solid #339966;
  }

  a[href*=".shex"] {
    color: #cc2900;
    border-bottom: 1px solid #cc2900;
  }

  a[href*=".tree"] {
    color: #e68a00;
    border-bottom: 1px solid #e68a00;
  }

  a[data-link-type=dfn] {
    color: #000000;
  }

  table.classinfo thead tr th[colspan] {
    text-align: left;
    font-size: 15px;
  }

  table.classinfo thead tr th {
    text-align: left;
    font-size: 14px;
  }

  table.classinfo tbody tr:nth-child(odd) {
    background-color: lightgray;
    font-size: 12px;
  }

  table.classinfo tbody tr td {
    font-size: 12px;
  }

  table.operation {
    border-collapse: separate;
    border: 3px solid #808080;
    margin-bottom: .5em;
  }

  table.operation thead tr {
    font-size: 14px;
  }

  table.operation thead th {
    background-color: #005A9C;
    color: #FFF;
  }

  table.operation th[colspan] {
    text-align: left;
  }

  table.operation td[colspan] {
    text-align: left;
  }

  table.operation tbody td {
    font-size: 13px;
    text-align: left;
  }

  table.operation code {
    background-color: #DCDCDC;
    color: #000;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;  
  }

  .opdetails code {
    background-color: #DCDCDC; 
    color: #000;
    font-weight: bold;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;
  }

  .opdetails code.vocab {
    color: #339966;
    background-color: #FFFFFF;
  }

  .opdetails ol {
    margin-left: 0;
    padding-left: 1em;
  }

	code.container {
		color: #005555;
	}

	code.notes {
		color: #770033;
	}

	code.citation {
		color: #330077;
	}

	code.image {
		color: #337700;
	}

    code.vocab {
		color: #339966;
	}
</style>

<div boilerplate="copyright">
  <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2020
  <a href="https://www.w3.org/">W3C</a>®
  (<a href="https://www.csail.mit.edu/">MIT</a>,
   <a href="https://www.ercim.eu/">ERCIM</a>,
   <a href="https://www.keio.ac.jp/">Keio</a>,
   <a href="https://ev.buaa.edu.cn/">Beihang</a>).
   W3C
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
   <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a>
   rules apply.
</div>

Introduction {#introduction}
=====================

*This section is non-normative.*

Realizing the value proposition of the Semantic Web lies in building useful and
robust applications that can interoperate over linked data. Protocols such as
[[LDP]] and Solid organize linked data graphs into resource hierarchies,
providing a foundation upon which these robust and interoperable applications
can be created.

Application interoperability depends on applications sharing semantics for
relationships and data structures.  Existing technologies fulfill portions
of those dependencies:
* [=RDF=]&apos;s foundation in unambiguous identifiers provides an infrastructure
    that allows for interoperability, but does not specifically encourage or enforce it.
* [=Shape=] languages (e.g. [[ShEx]] and [[SHACL]]) provide machine-readable,
    enforceable data structure definitions on single resources.

For applications that operate on more complex and interconnected resources,
<i>[=Shape Trees=]</i> express the layout of those resources and associate them
with their respective [=shapes=].

[=Shape trees=] marry [=RDF=] vocabularies, shapes, and resources into
"little trees" that provide machine to machine interoperability, combining them
into concepts that humans can easily comprehend, such as medical records, notes,
notebooks, calendars, and financial records.

This allows one to treat a set of related resources as a single grouping, and
apply that to a range of operations including access control, data organization,
data validation, and data migration.

[=Shape trees=] are defined as an [=RDF=] graph structure that expresses a set
of expected behaviors by agents that work with them. These semantics CAN be
implemented by a [server](#server-side-agent), or a [=client-side agent=] 
that pre-processes requests
to a server. <span class="issue">Reword this to be client/server specific</span>

While [=shape trees=] are intended to adapt to different technology platforms
that support the notion of [=containers=] and [=resources=], examples in this
specification will reflect usage in an [[LDP]] environment.

Shape Tree {#tree}
=====================

A <dfn>shape tree</dfn> is a machine-readable [=RDF=] template describing the 
expected layout of a tree of resources in a [=container=]-based [=ecosystem=].
A [=shape tree=] expresses a tree hierarchy by containing
other [=shape trees=]. The terms used to express a [=shape tree=] are described 
using an [[RDF]] [vocabulary](shapetree.ttl).

A <dfn>shape tree instance</dfn> is a resource or set of resources assigned to 
and in conformance with a given [=shape tree=]. A resource in a
[=shape tree instance=] is considered to be a <dfn>managed resource</dfn>.

A [=shape tree=] is assigned to a [=managed resource=] by a 
associating a <dfn>shape tree locator</dfn> with that resource. A client 
may discover that a resource is a [=managed resource=] through the
[=shape tree locator=] associated with that resource.

[=Shape trees=] prescribe physical hierarchies and can reference other
shape trees to form virtual hierarchies. In
a physical hierarchy, a [=shape tree=] expresses a [=managed resource=] 
that explicitly contains another [=managed resource=] via `st:contains`. 
For example, in [[LDP]] and [[Solid]], this would be
the equivalent of using `ldp:contains` to identify a resource member of
a given container. 

Issue: Add example

In a virtual hierarchy, a [=shape tree=] identifies
links in a graph connecting two disparate [=managed resources=] via 
`st:references`.

Issue: Add example

A [=shape tree=] may prescribe that a [=managed resource=] be one of three
types via `st:expectsType`:

<table class="data" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <tbody>
    <tr>
      <td><code class="vocab">st:ShapeTreeResource</code></td>
      <td>Regular RDF resource that is not a container</td>
    </tr>
    <tr>
      <td><code class="vocab">st:ShapeTreeContainer</code></td>
      <td>RDF resource that contains other resources</td>
    </tr>
    <tr>
      <td><code class="vocab">st:ShapeTreeNonRDFResource</code></td>
      <td>Non-RDF resource such as binaries or images</td>
    </tr>
  </tbody>
</table>

A [=shape tree=] may prescribe that a [=managed resource=] conforms to a
given [[ShEx]] or [[SHACL]] shape via `st:validatedBy`. 

Issue: Add example

Let <code>ST</code> be a [=shape tree=]. 
Let <code>STI</code> be a corresponding [=shape tree instance=].

* An { `ST` <code class="vocab">st:expectsType</code> `T` } [=arc=] identifies 
    the resource type `T` of a  corresponding [=managed resource=] 
    <code>R</code> in <code>STI</code> 
    where `T` <em class="rfc2119">MUST</em> be one of
    <code class="vocab">st:ShapeTreeResource</code>,
    <code class="vocab">st:ShapeTreeContainer</code>, or
    <code class="vocab">st:ShapeTreeNonRDFResource</code>.
* An { `ST` <code class="vocab">rdfs:label</code> `L` } [=arc=]
    indicates that there is exactly one corresponding [=managed resource=] 
    `R` in `STI` and it has the name `L`.
* An { `ST` <code class="vocab">st:validatedBy</code> `SH` }
    [=arc=] indicates that [=managed resource=] `R` <em class="rfc2119">MUST</em>
    have exactly one node which conforms to [=shape=] `SH`.
* An { `ST` <code class="vocab">st:contains</code> `R2` }
    [=arc=] indicates a nested [=shape tree=] and corresponding nested
    resource `R2`.
* An { `ST` <code class="vocab">st:references</code> `ST2` }
    [=arc=] indicates that [=shape tree=] `ST2` is referenced through the
    instance data of `STI`. <span class="issue">explode requirements
    for st:references here</span>
    
* An { `ST` <code class="vocab">st:supports</code> `ST3` }
    [=arc=] indicates that `ST` provides a different representation of
    `ST3` for aggregation purposes.

A { `ST` <code class="vocab">st:hasShapeTreeDecoratorIndex</code> `DI` }
    [=arc=] indicates the location of an index of [SKOS hierarchies](#skos-graph) 
    that describes `ST`.

## Shape Tree Schema ## {#st-schema}

<figure id="shapetree-shex">
  <figcaption>ShEx Schema for a Shape Tree</figcaption>
	<pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/st#&gt;
  PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

	&lt;#ShapeTree&gt; {
    a st:ShapeTree ;
	  (
	    st:expectsType [st:ShapeTreeContainer] ;
	    st:contains @&lt;#ShapeTree&gt; +
	  ) ;
    rdfs:label xsd:string ? ;
	  st:references @&lt;#ReferencedShapeTree&gt; * ;
	  st:validatedBy IRI ? ;
    st:contains IRI ? ;
    st:supports IRI ? ;
	}

	&lt;#ReferencedShapeTree&gt; {
	  st:hasShapeTree IRI ;
	  st:traverseViaShapePath xsd:string
	}
	</pre>
</figure>

## Shape Tree Locator Schema ## {#st-locator-schema}

<figure id="shapetree-shex">
  <figcaption>ShEx Schema for a Shape Tree Locator</figcaption>
	<pre highlight="turtle">
PREFIX st: &lt;http://www.w3.org/ns/st#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

&lt;#ShapeTreeLocatorShape&gt; {
  a [st:ShapeTreeLocator] ;
  st:location {
    st:hasRootShapeTree IRI ;
    st:hasShapeTree IRI ;
    st:hasShapeTreeInstanceRoot IRI ;
    st:node IRI ;
    st:shape IRI ;
  }+
}	</pre>
</figure>

The cardinality of <code class="vocab">st:location</code> is <code>+</code> (i.e. one or more).
If there are more than one location, all apply to the document or Container described by the <code class="vocab">ShapeTreeLocator</code>.

In the following example, the Shape Tree Locator (<code>&lt;#loc&gt;</code>) has two instances of <code class="vocab">st:location</code>:

   	<figure id="fig-discover-head-response-managed">
  <figcaption>Example ShapeTreeLocator with Multiple Locations</figcaption>
    		<pre highlight="turtle">
PREFIX st: &lt;http://www.w3.org/ns/st#&gt;

&lt;#loc&gt;
  a st:ShapeTreeLocator ;
  st:location [
    st:hasRootShapeTree &lt;http://commonnote.example/commonnote#NotesContainer&gt; ;
    st:hasShapeTree &lt;http://commonnote.example/commonnote#Note&gt; ;
    st:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; ;
    st:node &lt;/data/CommonNotes/Note1#node2&gt; ;
    st:shape &lt;http://commonnote.example/schema#NotesContainer&gt; ;
  ], [
    st:hasRootShapeTree &lt;http://mysite.example/shapeTrees/management#UserData&gt; ;
    st:hasShapeTree &lt;http://mysite.example/shapeTrees/management#Container&gt; ;
    st:hasShapeTreeInstanceRoot &lt;/data/&gt; ;
    st:node &lt;/data/CommonNotes/Note1#node3&gt; ; # Not necessarily the same node.
    st:shape &lt;http://mysite.example/shapes#MyContainerShape&gt; ;
  ]
.
    		</pre>
                [[try it](http://shex.io/webapps/shex.js/doc/shex-simple?schema=PREFIX%20st%3A%20%3Chttp%3A%2F%2Fwww.w3.org%2Fns%2Fst%23%3E%0APREFIX%20xsd%3A%20%3Chttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23%3E%0A%0A%3C%23ShapeTreeLocatorShape%3E%20%7B%0A%20%20a%20%5Bst%3AShapeTreeLocator%5D%20%3B%0A%20%20st%3Alocation%20%7B%0A%20%20%20%20st%3AhasRootShapeTree%20IRI%20%3B%0A%20%20%20%20st%3AhasShapeTree%20IRI%20%3B%0A%20%20%20%20st%3AhasShapeTreeInstanceRoot%20IRI%20%3B%0A%20%20%20%20st%3Anode%20IRI%20%3B%0A%20%20%20%20st%3Ashape%20IRI%20%3B%0A%20%20%7D%2B%0A%7D&amp;data=PREFIX%20st%3A%20%3Chttp%3A%2F%2Fwww.w3.org%2Fns%2Fst%23%3E%0A%0A%3C%23loc%3E%0A%20%20a%20st%3AShapeTreeLocator%20%3B%0A%20%20st%3Alocation%20%5B%0A%20%20%20%20st%3AhasRootShapeTree%20%3Chttp%3A%2F%2Fcommonnote.example%2Fcommonnote%23NotesContainer%3E%20%3B%0A%20%20%20%20st%3AhasShapeTree%20%3Chttp%3A%2F%2Fcommonnote.example%2Fcommonnote%23Note%3E%20%3B%0A%20%20%20%20st%3AhasShapeTreeInstanceRoot%20%3C%2Fdata%2FCommonNotes%2F%3E%20%3B%0A%20%20%20%20st%3Anode%20%3C%2Fdata%2FCommonNotes%2FNote1%23node2%3E%20%3B%0A%20%20%20%20st%3Ashape%20%3Chttp%3A%2F%2Fcommonnote.example%2Fschema%23NotesContainer%3E%20%3B%0A%20%20%5D%2C%20%5B%0A%20%20%20%20st%3AhasRootShapeTree%20%3Chttp%3A%2F%2Fmysite.example%2FshapeTrees%2Fmanagement%23UserData%3E%20%3B%0A%20%20%20%20st%3AhasShapeTree%20%3Chttp%3A%2F%2Fmysite.example%2FshapeTrees%2Fmanagement%23Container%3E%20%3B%0A%20%20%20%20st%3AhasShapeTreeInstanceRoot%20%3C%2Fdata%2F%3E%20%3B%0A%20%20%20%20st%3Anode%20%3C%2Fdata%2FCommonNotes%2FNote1%23node3%3E%20%3B%20%23%20Not%20necessarily%20the%20same%20node.%0A%20%20%20%20st%3Ashape%20%3Chttp%3A%2F%2Fmysite.example%2Fshapes%23MyContainerShape%3E%20%3B%0A%20%20%5D%0A.%0A&amp;shape-map=%3C%23loc%3E%40%3C%23ShapeTreeLocatorShape%3E&amp;interface=human&amp;success=proof&amp;regexpEngine=eval-threaded-nerr&amp;manifestURL=)]
    	</figure>

These assert that, in the described document:
<ul>
  <li>(described by the upper <code class="vocab">st:location</code>)<ul>
    <li>The RDF node <code>&lt;/data/CommonNotes/Note1#node2&gt;</code> conforms to the shape <code>&lt;http://commonnote.example/schema#NotesContainer&gt;</code></li>
    <li>The Container <code>&lt;/data/CommonNotes/&gt;</code> is the root of this Managed Hierarchy and conforms to the shape tree <code>&lt;http://commonnote.example/commonnote#NotesContainer&gt;</code></li>
  </ul>
  <li>(described by the lower <code class="vocab">st:location</code>)<ul>
    <li>The RDF node <code>&lt;/data/CommonNotes/Note1#node3&gt;</code> conforms to the shape <code>&lt;http://mysite.example/shapeTrees/management#Container&gt;</code></li>
    <li>The Container <code>&lt;/data/&gt;</code> is the root of this Managed Hierarchy and conforms to the shape tree <code>&lt;http://mysite.example/shapeTrees/management#UserData&gt;</code></li>
  </ul>
</ul>

In this example, the two locations describe two different nodes in <code>&lt;Note1&gt;</code>, <code>&lt;node2&gt;</code> and <code>&lt;node3&gt;</code>.
These nodes are validated according to the data in the described document (probably, but not necessarily, <code>&lt;Note1&gt;</code>).
If a described node does not appear in the described document, it can't satisfy any Triple Constraints.

Shape Tree Operations {#operations}
=====================

Working with [=shape trees=] entails using several higher-level operations --
each of which may represent one or more HTTP requests and/or pieces of
processing logic.

The key operations used to manage [=shape trees=] are:
* [Discover Shape Tree](#discover)
* [Plant Shape Tree](#plant-shapetree)
* [Create Data Instance](#create-data-instance)
* [Update Data Instance](#update-data-instance)
* [Delete Data Instance](#delete-data-instance)
* [Unplant Shape Tree](#unplant-shapetree)

These operations make use of reusable, internal algorithms defined in
[Shape Tree Algorithms](#algorithms).

## Discover Shape Tree ## {#discover}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>discover shape tree</b> operation entails discovering what, if any, 
        shape trees are managing a given container.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`URI`</td>
      <td>The URI of the resource to discover shape trees for</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`LOCATORS`</td>
      <td>Collection of <code class="vocab">st:ShapeTreeLocator</code> subjects</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform a HEAD on the provided <code>URI</code> to discover Shape Tree metadata URI

      Note: This step <em class="rfc2119">SHOULD</em> be performed by a
      [=client-side agent=].

    	<figure id="fig-discover-head-request">
    		<figcaption><code>URI</code> = <code>/data/CommonNotes/</code></figcaption>
    		<pre highlight="http">
    		HEAD /data/CommonNotes/
    		</pre>
    	</figure>

    	<figure id="fig-discover-head-response">
    		<figcaption>Discover Container Shape Tree Metadata - HEAD container -
        Response</figcaption>
    		<pre highlight="http">
    		HTTP/1.1 200 OK
    		Link: &lt;/data/CommonNotes/meta/bc1b490a#loc&gt;;
              rel="http://shapetrees.org/#ShapeTreeLocator"
        Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
    		...other headers omitted...
    		</pre>
    	</figure>

      Discovering shape trees only applies to URIs of containers. A status code of
      400 <em class="rfc2119">MUST</em> be returned if no Link headers with a
      relation type which maps to the implementation's notion of a [=container=]
      (e.g. `http://www.w3.org/ns/ldp#Container` in an LDP context) exists.

    	Let <code>METAURI</code> be the URI of the shape tree metadata resource
        pertaining to <code>URI</code> through the Link header with relation
        `http://shapetrees.org/#ShapeTreeLocator`.


1. Perform a GET on the discovered Shape Tree metadata resource (<code>METAURI</code>)

      Note: This step <em class="rfc2119">SHOULD</em> performed by a
      [=client-side agent=].

    	<figure id="fig-discover-get-metadata">
    		<figcaption>Discover Container Shape Tree Metadata -
        Get Shape Tree metadata - Request</figcaption>
    		<pre highlight="http">
    		GET /data/CommonNotes/meta/bc1b490a#loc
    		</pre>
    	</figure>

    	<figure id="fig-discover-head-response-managed">
    		<figcaption>Discover Container Shape Tree Metadata -
        GET Shape Tree metadata - Managed Container Response</figcaption>
    		<pre highlight="turtle">
PREFIX st: &lt;http://www.w3.org/ns/st#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

&lt;#loc&gt;
  a st:ShapeTreeLocator ;
  st:location [
    st:hasRootShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
    st:hasShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
    st:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; ;
    st:node &lt;/data/CommonNotes/Note1#doc&gt; ;
    st:shape &lt;http://commonnote.example/schema#NotesContainer&gt; ;
  ]
.
    		</pre>
    	</figure>

    	<figure id="fig-discover-head-response-unmanaged">
    		<figcaption>Discover Container Shape Tree Metadata -
        GET Shape Tree metadata - Unmanaged Container Response</figcaption>
    		<pre highlight="http">
    		HTTP/1.1 404 NOT FOUND
    		</pre>
    	</figure>

    	A 404 status code indicates that no [=shape trees=] manage this
        [=container=], and so it <em class="rfc2119">MUST</em> be considered
        an [=Unmanaged Container=].

1. Collect any navigable shape trees

      Note: This step <em class="rfc2119">SHOULD</em> performed by a
      [=client-side agent=].

    	If the ```<#loc>``` subject has one or more
        <code class="vocab">st:location</code> predicates, this
        container <em class="rfc2119">MUST</em> be considered a [=Managed Container=].

      Let <code>MC</code> be this [=managed container=].

    	The <code class="vocab">st:hasShapeTree</code> of each
        <code class="vocab">st:ShapeTreeLocator</code> subject specifies what
        [=shape tree=] manages <code>MC</code>.

      The IRI of each <code class="vocab">st:ShapeTreeLocator</code> describing a
        [=shape tree=] managing <code>MC</code> <em class="rfc2119">SHOULD</em>
        be returned.

## Plant Shape Tree ## {#plant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>plant</b> operation marks a container (new or existing) as being
        managed by one or more shape trees.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A POST or PUT HTTP request with the following characteristics:
        * Let <code>LINKST</code> be one or more Link headers with the relation of
            &quot;http://shapetrees.org/#ShapeTreeLocator&quot;.  This represents one or more
            [=shape trees=] to be planted by the plant operation.
        * A Link header with the relation &quot;type&quot; and a value of a compatible
            [=container=] (e.g. &lt;http://www.w3.org/ns/ldp#BasicContainer&gt;)
        * Let <code>LINKFN</code> be an <em class="rfc2119">OPTIONAL</em> Link
            header with the relation of
            &quot;http://shapetrees.org/#FocusNode&quot;.  This represents the
            target subject within the request body (used for ShEx validation, etc.)
        * Let <code>LINKTST</code> be an <em class="rfc2119">OPTIONAL</em>
            Link header with the relation of &quot;http://shapetrees.org/#TargetShapeTree&quot;
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A HTTP response containing a Location header with the URI of the container
        that the requested shape trees (<code>LINKST</code>) are planted in
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

  Note: A plant operation <em class="rfc2119">MAY</em>
    be performed by either a [client](#client-side-agent) or [=server-side agent=].

  * Let <code>TC</code> be the <dfn>Target Container</dfn> - The container that
        will contain instances of the [=planted shape tree=].
        This container may or may not already exist.
  * Let <code>PC</code> be the <dfn>Parent Container</dfn> - The container that
        will contain the new or existing [=target container=] representing the
        [=planted shape tree=].  When <code>REQ</code> is a POST, this will be the
        location URL.  For PUT, this will be the parent of the PUT container.


1. Preconditions

    Note: This step <em class="rfc2119">SHOULD</em> be performed by a
        [=client-side agent=].

    1. Ensure the [=Parent Container=] (<code>PC</code>) exists.  If not, this
        operation <em class="rfc2119">MUST</em> return a 404 status code.
    1. [Discover](#discover) any planted [=shape tree=] IRIs managing <code>PC</code>.
    	1. Let <code>PARENTST</code> be the collection of dereferenced shape tree
            IRIs discovered for <code>PC</code>
    1. If the [=Target Container=] (<code>TC</code>) already exists,
        [discover](#discover) any previously [=planted shape tree=] IRIs.
    	1. Collect any existing shape tree IRIs and combine with the IRIs of the
            <code>LINKST</code> provided via the request Link header to represent
            the full collection of existing and proposed shape trees for <code>TC</code>.
    	1. Let <code>ALLST</code> be the collection of dereferenced shape tree IRIs
            representing both existing and <code>LINKST</code> IRIs

1. Static Validation of Shape Trees for Conflicts

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

    1. Iterate <code>ALLST</code> to validate that none of the following conditions
        are met:
    	* any shape tree has a <code class="vocab">st:expectsResourceType</code>
            with a value other than <code class="vocab">st:ShapeTreeContainer</code>
    	* more than one shape tree has a <code class="vocab">st:validatedBy</code> value
    	* more than one shape tree has a <code class="vocab">st:contains</code> value

    If any of the above static validations fail, this operation
        <em class="rfc2119">MUST</em> return a 400 status code.

1. Validate graph body

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

    Issue: Must detail how to differentiate between ShEx and SHACL validation

    1. Let <code>VST</code> be the validating shape tree that is identified by the
        only [=shape tree=] in <code>ALLST</code> having a
        <code class="vocab">st:validatedBy</code> value
    1. If <code>VST</code> is present and the plant operation (<code>REQ</code>)
        includes an RDF graph body and ShEx validation is used and a [=Focus Node=]
        (<code>LINKFN</code>) is not present, this operation
        <em class="rfc2119">MUST</em> return a 422 status code
    1. Perform a validation of the RDF graph body of <code>REQ</code> using the
        <code>VST</code> <code class="vocab">st:validatedBy</code> shape,
        targeting the graph's <code>LINKFN</code>.  If validation fails, this
        operation <em class="rfc2119">MUST</em> return a 422 status code

1. Validate against parent container

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=]..

    1. Determine if the [=Parent Container=] (<code>PC</code>) is a
        [=Managed Container=] by evaluating if <code>PARENTST</code> is not empty
    2. If <code>PC</code> is a [=Managed Container=] call the
        [validate proposed resource](#validate-proposed-resource) algorithm with
        parameters:

      <table class="data operation" align="center">
        <colgroup></colgroup>
        <colgroup></colgroup>
        <colgroup></colgroup>
        <thead>
          <tr>
            <th><b>Parameter</b></th>
            <th><b>Value</b></th>
            <th><b>Notes</b></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>URI</code></td>
            <td><code>PC</code></td>
            <td>
              The [=parent container=] that will contain the [=target container=]
            </td>
          </tr>
          <tr>
            <td><code>STH</code></td>
            <td><code>LINKTST</code></td>
            <td>
              Link header with the relation of
              "http://shapetrees.org/#TargetShapeTree"
            </td>
          </tr>
          <tr>
            <td><code>RT</code></td>
            <td><code class="vocab">st:ShapeTreeContainer</code></td>
            <td>The resource type being created/modified</td>
          </tr>
      </table>

1. Create Target Container (<code>TC</code>), if necessary

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=]..

    1. If <code>TC</code> does not exist, create it.

    	<figure id="fig-plant-create-target-request">
    		<figcaption>Create Target Container - Request</figcaption>
    		<pre highlight="http">
    		POST /<b><i>&lt;PC&gt;</b></i>/
    		Slug: <b><i>&lt;TC&gt;</b></i>;
    		Link: &lt;http://www.w3.org/ns/ldp#BasicContainer&gt;; rel="type"
    		</pre>
    	</figure>

    	<figure id="fig-plant-create-target-response">
    		<figcaption>Create Target Container - Response</figcaption>
    		<pre highlight="http">
    		HTTP 201 CREATED
    		Location: http://pod.example/<b><i>&lt;PC&gt;</b></i>/<b><i>&lt;TC&gt;</b></i>/
    		Content-type: text/turtle; charset=utf-8
    		Content-length: 396
    		</pre>
    	</figure>

1. Update Shape Tree Meta Data for Target Container (<code>TC</code>)

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=]..

    1. Update Target Container <code>TC</code> Metadata (<code>METAURI</code>)

    	1. Iterate the collection of shape trees to be planted (<code>LINKST</code>),
            let <code>LINKSTI</code> be the current shape tree in context.
    	1. Call algorithm [Update Container Metadata](#update-container-metadata) with
            parameters:

    	<table class="data operation" align="center">
    		<thead>
    			<tr>
    				<th><b>Parameter</b></th>
    				<th><b>Value</b></th>
            <th><b>Notes</th>
    			</tr>
    		</thead>
    		<tbody>
          <tr>
            <td><code>TC</code></td>
            <td><code>TC</code></td>
            <td>
              The [=target container=] to that will contain instance data of the
              [=shape tree=]
            </td>
          </tr>
    			<tr>
    				<td><code>ROOTST</code></td>
    				<td><code>LINKSTI</code></td>
            <td>The root [=shape tree=] at the top of the hierarchy</td>
    			</tr>
    			<tr>
    				<td><code>ST</code></td>
    				<td><code>LINKSTI</code></td>
            <td>The [=shape tree=] managing the [=target container=]</td>
    			</tr>
    			<tr>
    				<td><code>ROOTPATH</code></td>
    				<td><code>TC</code></td>
            <td>
              The [=target container=] to that will contain instance data of the
              [=shape tree=]
            </td>
    			</tr>
    	</table>

1. Initialize Static Content

    Note: This step <em class="rfc2119">MAY</em> be performed by either
        a [client](#client-side-agent) or [=server-side agent=]..

    1. Let <code>CST</code> be the shape tree having a
        <code class="vocab">st:contains</code> value (if one exists) from the
        list of shape trees that were planted <code>LINKST</code>
    1. Iterate any <code class="vocab">st:contains</code> IRIs within
        <code>CST</code>, letting <code>CSTI</code> be the current IRI in context
    1. Let <code>CSTIST</code> be the shape tree resulting in dereferencing IRI
        <code>CSTI</code>
    1. If <code>CSTIST</code> has a <code class="vocab">rdfs:label</code> value,
        let <code>LABEL</code> be the value of rdfs:label for <code>CSTIST</code>,
        and call algorithm
        [Initialize Statics](#initialize-statics) with parameters:

      <table class="data operation" align="center">
        <thead>
          <tr>
            <th><b>Parameter</b></th>
            <th><b>Value</b></th>
            <th><b>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>PC</code></td>
            <td><code>TC</code></td>
            <td>
              The [=target container=] to that will contain instance data of the
              [=shape tree=]
            </td>
          </tr>
          <tr>
            <td><code>SST</code></td>
            <td><code>CSTIST</code></td>
            <td>The matching contained [=shape tree=]</td>
          </tr>
          <tr>
            <td><code>RST</code></td>
            <td><code>CST</code></td>
            <td>The [=shape tree=] containing a <code class="vocab">st:container</code>
          </tr>
          <tr>
            <td><code>RC</code></td>
            <td><code>TC</code></td>
            <td>
              The [=target container=] to that will contain instance data of the
              [=shape tree=]
            </td>
          </tr>
      </table>

## Create Data Instance ## {#create-data-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>create data instance</b> operation creates an instance of a shape
        tree within a managed container.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A POST or PUT HTTP request with the following characteristics:
        * A Link header with the relation &quot;type&quot; and a value of a compatible
            [=container=] (e.g. &lt;http://www.w3.org/ns/ldp#BasicContainer&gt;)
        * Let <code>LINKFN</code> be an <em class="rfc2119">OPTIONAL</em> Link
            header with the relation of
            &quot;http://shapetrees.org/#FocusNode&quot;.  This represents the
            target subject within the request body (used for ShEx validation, etc.)
        * Let <code>LINKTST</code> be a <em class="rfc2119">REQUIRED</em>
            Link header with the relation of &quot;http://shapetrees.org/#TargetShapeTree&quot;
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

* Let <code>PC</code> be the [=Parent Container=]

1. Preconditions

    Note: This step <em class="rfc2119">SHOULD</em> be performed by a
        [=client-side agent=].

    1. Ensure the [=Parent Container=] (<code>PC</code>) exists.  If not, return
        this operation <em class="rfc2119">MUST</em> return a 404 status code.
    1. [Discover](#discover) any [=planted shape tree=] IRIs managing <code>PC</code>.
    	1. Let <code>PARENTST</code> be the collection of dereferenced shape tree IRIs
            discovered for <code>PC</code>

1. Validate against parent container

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

    1. Determine if the [=Parent Container=] (<code>PC</code>) is a
        [=Managed Container=] by evaluating if <code>PARENTST</code> is not empty
    2. If <code>PC</code> is a [=Managed Container=] call the
        [validate proposed resource](#validate-proposed-resource) algorithm
        with parameters:

      <table class="data operation" align="center">
        <thead>
          <tr>
            <th><b>Parameter</b></th>
            <th><b>Value</b></th>
            <th><b>Notes</b></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>URI</code></td>
            <td><code>PC</code></td>
            <td>
              The [=parent container=] to that will contain the [=target container=]
            </td>
          </tr>
          <tr>
            <td><code>STH</code></td>
            <td><code>LINKTST</code></td>
            <td>The [=shape tree=] managing the [=target container=]</td>
          </tr>
          <tr>
            <td><code>RT</code></td>
            <td>
              <code class="vocab">st:ShapeTreeContainer</code> or
              <code class="vocab">st:ShapeTreeResource</code> or
              <code class="vocab">st:ShapeTreeNonRDFResource</code>
            </td>
            <td>The resource type being created</td>
          </tr>
      </table>

1. Create Resource

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=]..

1. Initialize Static Content

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
    [client](#client-side-agent) or [=server-side agent=].

    1. Iterate any <code class="vocab">st:contains</code> IRIs within
        <code>MCST</code>, letting <code>CSTI</code> be the current IRI in context
    1. Let <code>CSTIST</code> be the [=shape tree=] resulting in dereferencing IRI
        <code>CSTI</code>
    1. If <code>CSTIST</code> has a <code class="vocab">rdfs:label</code> value,
        let <code>LABEL</code> be the value of
        <code class="vocab">rdfs:label</code> for <code>CSTIST</code>, and
        call algorithm [Initialize Statics](#initialize-statics) with parameters:

      <table class="data operation" align="center">
        <thead>
          <tr>
            <th><b>Parameter</b></th>
            <th><b>Value</b></th>
            <th><b>Note</b></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>PC</code></td>
            <td><code>TC</code></td>
            <td>
              The [=target container=] that will contain instance data of the
              [=shape tree=]
            </td>
          <tr>
            <td><code>SST</code></td>
            <td><code>CSTIST</code></td>
            <td>The matching [=shape tree=]
          </tr>
          <tr>
            <td><code>RST</code></td>
            <td><code>CST</code></td>
            <td>The parent [=shape tree=] managing the parent container
          </tr>
          <tr>
            <td><code>RC</code></td>
            <td><code>TC</code></td>
            <td>
              The [=target container=] that will contain instance data of the
              [=shape tree=]
            </td>
          </tr>
      </table>

## Update Data Instance ## {#update-data-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>update data instance</b> operation updates an instance of a
        [=shape tree=] within a managed container.      
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A PUT or PATCH HTTP request with the following characteristics:
        * Let <code>LINKFN</code> be an <em class="rfc2119">OPTIONAL</em>
            Link header with the relation of "http://shapetrees.org/#FocusNode".
            This represents the target subject within the request body
            (used for ShEx validation, etc.)
        * Let <code>LINKTST</code> be an <em class="rfc2119">REQUIRED</em> Link
            header with the relation of "http://shapetrees.org/#TargetShapeTree"
        * Let <code>RT</code> be the resource type inferred by the request's 
            content type header
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

* Let <code>PC</code> be the [=Parent Container=]

1. Preconditions

    Note: This step <em class="rfc2119">SHOULD</em> be performed by a
        [=client-side agent=].

    1. Ensure the [=Parent Container=] (<code>PC</code>) exists.
        If not, this operation <em class="rfc2119">MUST</em> return a 404 status code.
    1. [Discover](#discover) any [=planted shape tree=] IRIs managing <code>PC</code>.
        1. Let <code>PARENTST</code> be the collection of dereferenced shape tree
            IRIs discovered for <code>PC</code>

1. Validate against parent container

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

    1. Determine if the [=Parent Container=] (<code>PC</code>) is a
        [=Managed Container=] by evaluating if <code>PARENTST</code> is not empty
    1. If <code>PC</code> is a [=Managed Container=] call the
        [validate proposed resource](#validate-proposed-resource) algorithm with
        parameters:

      <table class="data operation" align="center">
        <thead>
          <tr>
            <th><b>Parameter</b></th>
            <th><b>Value</b></th>
            <th><b>Notes</b></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>URI</code></td>
            <td><code>PC</code></td>
            <td>
              The [=parent container=] that will contain the [=target container=]
            </td>
          </tr>
          <tr>
            <td><code>STH</code></td>
            <td><code>LINKTST</code></td>
            <td>The [=shape tree=] managing the [=target container=]</td>
          </tr>
          <tr>
            <td><code>RT</code></td>
            <td><code>RT</code></td>
            <td>The resource type being modified</td>
          </tr>
      </table>

1. Update Resource

    Note: This step <em class="rfc2119">MAY</em> be performed by either a client
        or server side agent.

## Delete Data Instance ## {#delete-data-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>delete data instance</b> operation deletes an instance of a
        [=shape tree=] within a managed container.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>
        A DELETE HTTP request
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Delete Resource

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

## Unplant Shape Tree ## {#unplant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        The <b>unplant shape tree</b> operation unassigns the provided [=shape tree=]
        from the provided [=container=].  If there are no remaining [=shape trees=]
        managing the [=container=], it would no longer be considered a
        [=managed container=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>
        A DELETE HTTP request with the following characteristics:
          * Let <code>LINKST</code> be a Link header with the relation of
              "http://shapetrees.org/#ShapeTreeLocator" indicating the [=shape tree=] that
              should no longer manage the target [=container=]
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

* Let <code>PC</code> be the parent [=Container=] of the resource being deleted
* Let <code>TC</code> be the [=Container=] of the resource being deleted

1. Remove Shape Tree Metadata

    Note: This step <em class="rfc2119">MAY</em> be performed by either a
        [client](#client-side-agent) or [=server-side agent=].

    Call the [remove shape tree metadata](#remove-shapetree-metadata) algorithm with
    parameters:

          <table class="data operation" align="center">
            <thead>
              <tr>
                <th><b>Parameter</b></th>
                <th><b>Value</b></th>
                <th><b>Notes</b></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>URI</code></td>
                <td><code>TC</code></td>
                <td>
                  The [=target container=] that the [shape tree] is being removed
                  from
                </td>
              </tr>
              <tr>
                <td><code>ST</code></td>
                <td><code>LINKST</code></td>
                <td>The [=shape tree=] no longer managing the <code>tc</code></td>
              </tr>
          </table>

Shape Tree Algorithms {#algorithms}
=====================

The below algorithms detail key pieces of logic required for
[=shape tree=] implementations.

## Validate Proposed Resource Against Parent Container ## {#validate-proposed-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for determining if a proposed resource
        (which may more specifically be a [=container=], [=resource=], or [=non-RDF source=]) is
        valid to be created within a given [=container=].

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either a
            [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`PC`</td>
      <td>
        The URI of the [=Managed Container=] that will contain the proposed resource
      </td>
    </tr>
    <tr>
      <td>`STH`</td>
      <td>
        The target shape tree hint, from the request's Link header with the relation of 
        "http://shapetrees.org/#TargetShapeTree"
      </td>
    </tr>
    <tr>
      <td>`RT`</td>
      <td>
        The resource type of proposed resource ([=container=], [=resource=], [=non-RDF source=])
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`MCST`</td>
      <td>
        The URI of the matching contains shape tree
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Determine if the [=Parent Container=] (<code>PC</code>) is a
    [=Managed Container=] by evaluating if <code>PARENTST</code> is not empty
1. If <code>PC</code> is a [=Managed Container=], let <code>MCST</code> be the
    matching contained [=shape tree=] which is the result of calling the
    [matching contained shape tree](#matching-contained-shapetree) algorithm
    with parameters:
    <table class="data operation" align="center">
      <thead>
        <tr>
          <th><b>Parameter</b></th>
          <th><b>Value</b></th>
          <th><b>Notes</b></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>URI</code></td>
          <td><code>PC</code></td>
          <td>The parent container to discover [=shape trees=] for
        </tr>
        <tr>
          <td><code>STH</code></td>
          <td><code>STH</code></td>
          <td>The [=shape tree=] hint provided as a Link header
        </tr>
        <tr>
          <td><code>RT</code></td>
          <td><code>RT</code></td>
          <td>The resource type being created/modified</td>
        </tr>
    </table>
1. If <code>RT</code> does not match <code>MCST</code>'s
    <code class="vocab">st:expectsType</code> value, this operation
    <em class="rfc2119">MUST</em> return a 422 status code
1. If <code>MCST</code> has a <code class="vocab">st:validatedBy</code> value,
    and the plant operation (<code>REQ</code>) includes an RDF graph body and
    ShEx validation is used and a [=Focus Node=] (<code>LINKFN</code>) is not
    present, this operation <em class="rfc2119">MUST</em> return a
    422 status code
1. Perform a validation of the RDF graph body of <code>REQ</code> using the
    <code>mcst</code> <code class="vocab">st:validatedBy</code> shape,
    targeting the graph's <code>LINKFN</code>.  If validation fails,
    this operation <em class="rfc2119">MUST</em> return a 422 status code

## Find Matching Contained Shape Tree ## {#matching-contained-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for determining which [=shape tree=] within a set
        of shape trees mentioned in <code class="vocab">st:contains</code> is
        applicable for a given proposed resource.

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either
            a [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`URI`</td>
      <td>
        The URI of the [=Managed Container=] that will contain the proposed resource
      </td>
    </tr>
    <tr>
      <td>`STH`</td>
      <td>
        The target shape tree hint, from the request's Link header with the relation of 
        "http://shapetrees.org/#TargetShapeTree"
      </td>
    </tr>
    <tr>
      <td>`RT`</td>
      <td>
        The resource type of proposed resource ([=container=], [=resource=], [=non-RDF source=])
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`MCST`</td>
      <td>
        A single shape tree IRI that should be used for validation
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let <code>MST</code> be the shape trees managing <code>URI</code> found by
    [discovering](#discover) the shape trees
1. Let <code>CST</code> be the shape tree within <code>MST</code> with a
    <code class="vocab">st:contains</code> value(s)
1. Let <code>CCST</code> be the candidate shape trees for matching - populated
    by each <code class="vocab">st:contains</code> of <code>CST</code>
1. If <code>STH</code> is specified
    1. and <code>STH</code> does NOT exist within <code>CCST</code> this
          algorithm <em class="rfc2119">MUST</em> return a 400 status code
    1. and <code>STH</code> exists within <code>CCST</code> return
          <code>STH</code>
1. If <code>CCST</code> does not contain any of
    <code class="vocab">st:AllowAll</code>,
    <code class="vocab">st:AllowResources</code>,
    <code class="vocab">st:AllowContainers</code>,
    <code class="vocab">st:AllowNonRDFSources</code>,
    this algorithm <em class="rfc2119">MUST</em> return a status code of 422
1. If <code class="vocab">st:AllowNone</code> exists within
    <code>CCST</code>, this algorithm <em class="rfc2119">MUST</em>
    return a status code 422
1. If <code class="vocab">st:AllowAll</code> exists within
    <code>CCST</code>, return null - indicating that while no match was
    found, <code>PC</code> has been configured to allow resources of any
    type to be created without matching the shape tree
1. If <code class="vocab">st:AllowResources</code> exists within
    <code>CCST</code>:
    1. And the resource type (<code>RT</code>) is not a Resource,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type (<code>RT</code>) is a Resource,
          return null - indicating that while no match was found,
          <code>PC</code> has been configured to allow Resources to be
          created without matching the shape tree
1. If <code class="vocab">st:AllowContainers</code> exists within
    <code>CCST</code>:
    1. And the resource type (<code>RT</code>) is not a Container,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type (<code>RT</code>) is a Container,
          return null - indicating that while no match was found,
          <code>PC</code> has been configured to allow Containers to be
          created without matching the shape tree
1. If <code class="vocab">st:AllowNonRDFSources</code> exists within
    <code>CCST</code>:
    1. And the resource type (<code>RT</code>) is not a Non-RDF Source,
          this algorithm <em class="rfc2119">MUST</em>
          return a status code of 422
    1. And the resource type (<code>RT</code>) is a Non-RDF Source,
          return null - indicating that while no match was found,
          <code>PC</code> has been configured to allow non-RDF Sources to
          be created without matching the shape tree

## Initialize Static Content ## {#initialize-statics}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for initializing static content that is implied
        through the creation of its parent.  When called, it recursively seeks out
        resources to be statically created.

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either a
            [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`PC`</td>
      <td>
        The parent [=container=] that any statics would be created within
      </td>
    </tr>
    <tr>
      <td>`SST`</td>
      <td>
        The static shape tree to be initialized where an <code class="vocab">rdfs:label</code> is set
      </td>
    </tr>
    <tr>
      <td>`RST`</td>
      <td>
        The root shape tree that was planted at the top of this shape tree hierarchy
      </td>
    </tr>
    <tr>
      <td>`RC`</td>
      <td>
        The root container at the top of this shape tree hierarchy
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>NONE</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let <code>LABEL</code> be the <code class="vocab">rdfs:label</code> value of
    the provided &quot;static&quot; shape tree (<code>SST</code>)
1. Create the expected resource using a PUT in order to have control of resource
    naming, letting <code>CR</code> be the resulting resource that was created
    1. Set the appropriate Link header with "type" relation based on the
        <code class="vocab">st:expectsType</code> value of <code>SST</code>
1. If the <code class="vocab">st:expectsType</code> value of <code>SST</code>
    is <code class="vocab">st:ShapeTreeContainer</code>:
    1. Call algorithm [Update Container Metadata](#update-container-metadata)
        with parameters:
    	<table class="data operation" align="center">
    		<thead>
    			<tr>
    				<th><b>Parameter</b></th>
    				<th><b>Value</b></th>
            <th><b>Notes</b></th>
    			</tr>
    		</thead>
    		<tbody>
          <tr>
            <td><code>TC</code></td>
            <td><code>CR</code></td>
            <td>Created static resource</td>
    			<tr>
    				<td><code>ROOTST</code></td>
    				<td><code>RST</code></td>
            <td>The root [=shape tree=] of the hierarchy</td>
    			</tr>
    			<tr>
    				<td><code>ST</code></td>
    				<td><code>SST</code></td>
            <td>The [=shape tree=] to assign to <code>cr</code>
    			</tr>
    			<tr>
    				<td><code>ROOTPATH</code></td>
    				<td><code>RC</code></td>
            <td>The root container at the top of this shape tree hierarchy</td>
    			</tr>
    	</table>

    1. If <code>SST</code> has any values for
        <code class="vocab">st:contains</code>:
        1. Iterate any <code class="vocab">st:contains</code> IRIs within
            <code>SST</code>, letting <code>CSSTI</code> be the current IRI
            in context
        1. Let <code>CSSTIT</code> be the shape tree resulting in dereferencing
            IRI <code>CSSTI</code>
        1. If <code>CSSTIT</code> has a <code class="vocab">rdfs:label</code>
            value then recursively call algorithm
              [Initialize Statics](#initialize-statics) with parameters:
              <table class="data operation" align="center">
                <thead>
                  <tr>
                    <th><b>Parameter</b></th>
                    <th><b>Value</b></th>
                    <th><b>Notes</b></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>PC</code></td>
                    <td><code>CR</code></td>
                    <td>Created static resource, now the parent</td>
                  <tr>
                    <td><code>SST</code></td>
                    <td><code>CSSTIT</code></td>
                    <td>A [=shape tree=] to be recursively planted</td>
                  </tr>
                  <tr>
                    <td><code>RST</code></td>
                    <td><code>RST</code></td>
                    <td>The root [=shape tree=] of the hierarchy</td>
                  </tr>
                  <tr>
                    <td><code>RC</code></td>
                    <td><code>RC</code></td>
                    <td>The root container at the top of this shape tree hierarchy</td>
                  </tr>
              </table>

## Update Container Metadata ## {#update-container-metadata}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for updating the shape tree metadata for a
        container to reflect what shapetree(s) manage that container
        and the container's location relative to the broader hierarchy of shape trees.

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either a
            [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TC`</td>
      <td>
        The URI of the [=Container=] to update metadata for
      </td>
    </tr>
    <tr>
      <td>`ROOTST`</td>
      <td>
        The root [=shape tree=] within a hierarchy of shape tree containers
      </td>
    </tr>
    <tr>
      <td>`ST`</td>
      <td>
        A [=shape tree=] that will manage <code>TC</code>
      </td>
    </tr>
    <tr>
      <td>`ROOTPATH`</td>
      <td>
        Tthe URI of the root of this shape tree hierarchy, where <code>ROOTST</code> is planted
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>NONE</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform a HEAD on Target Container <code>TC</code>
	<figure id="fig-container-head-request">
		<figcaption>Discover Target Container Shape Tree Metadata URI -
    Request</figcaption>
		<pre highlight="http">
		HEAD /data/CommonNotes/
		</pre>
	</figure>

	<figure id="fig-container-head-response">
		<figcaption>Discover Target Container Shape Tree Metadata URI -
    Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 200 OK
		Link: &lt;/data/CommonNotes/meta/bc1b490a#loc&gt;; rel="http://shapetrees.org/#ShapeTreeLocator"
		...other headers omitted...
		</pre>
	</figure>

	Let <code>METAURI</code> be the URI of the shape tree metadata resource
    pertaining to <code>TC</code>.

1. Perform a GET on the Target Container's Shape Tree metadata (<code>METAURI</code>)
	<figure id="fig-container-get-metadata">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Request</figcaption>
		<pre highlight="http">
		GET /data/CommonNotes/meta/bc1b490a#loc
		</pre>
	</figure>

	<figure id="fig-container-get-response-managed">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Managed Response</figcaption>
		<pre highlight="turtle">
		PREFIX st: &lt;http://www.w3.org/ns/st#&gt;

		&lt;#loc&gt;
		  a st:ShapeTreeLocator ;
		  st:location [
		    st:hasRootShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
		    st:hasShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
		    st:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; ;
		    st:node &lt;/data/CommonNotes/Note1#doc&gt; ;
		    st:shape &lt;http://commonnote.example/schema#NotesContainer&gt; ;
		  ]
		.
		</pre>
	</figure>

	<figure id="fig-container-get-response-unmanaged">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Unmanaged Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 404 NOT FOUND
		</pre>
	</figure>

    If a 404 is returned that indicates that no shape trees manage this container.
    Let <code>EG</code> be the existing metadata graph resulting from dereferencing
    and parsing <code>METAURI</code>.

1. Populate the metadata graph with triples

    Using <code>EG</code>, if it exists, otherwise a new graph, the following
    triples should be added:

    <table class="data operationdetails" align="left">
    	<thead>
    		<tr>
    			<th>Subject</th>
    			<th>Predicate</th>
    			<th>Object</th>
    			<th>Description</th>
        </tr>
    	</thead>
    	<tbody>
    		<tr>
    			<td nowrap>&lt;#<b><i>generated UUID</i></b>&gt;</td>
    			<td>rdf:type</td>
    			<td><code class="vocab">st:ShapeTreeLocator</code></td>
    			<td>Indicates the RDF class of the subject</td>
    		</tr>
    		<tr>
    			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
    			<td><code class="vocab">st:hasRootShapeTree</code></td>
    			<td><b><i>ROOTST</i></b></td>
    			<td>
            Describes the shape tree planted at the root of this shape tree
            hierarchy
        </td>
    		</tr>
    		<tr>
    			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
    			<td><code class="vocab">st:hasShapeTree</code></td>
    			<td><b><i>ST</i></b></td>
    			<td>Describes the shape tree planted at this container</td>
    		</tr>
    		</tr>
    		<tr>
    			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
    			<td><code class="vocab">st:hasShapeTreeInstanceRoot</code></td>
    			<td><b><i>ROOTPATH</i></b></td>
    			<td>
            Describes the URI to the root container of this shape tree
            hierarchy
          </td>
    		</tr>
    		<tr>
    			<td>referenced <code class="vocab">st:ShapeTreeLocator</code> (e.g. &lt;#loc&gt;)</td>
    			<td><code class="vocab">st:location</code></td>
    			<td>&lt;#<b><i>generated UUID</i></b>&gt;</td>
    			<td>
            Identifies the <code class="vocab">st:node</code> and <code class="vocab">st:shape</code> for validation as well as the 
            corresponding node in the ShapeTree (<code class="vocab">st:hasShapeTree</code>),
            ShapeTree root in the resource hierarchy (<code class="vocab">st:hasShapeTreeInstanceRoot</code>) and
            root node in the ShapeTree (<code class="vocab">st:hasRootShapeTree</code>).
          </td>
    		</tr>
    	</tbody>
    </table>

1. Persist the above triples to <code>METAURI</code>.

## Remove Shape Tree From Container Metadata ## {#remove-shapetree-metadata}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for updating the shape tree metadata for a
        container to remove a [=shape tree=] from managing a container.

        Note: This algorithm <em class="rfc2119">MAY</em> be performed by either a
            [client](#client-side-agent) or [=server-side agent=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TC`</td>
      <td>
        The URI of the [=Container=] to update metadata for
      </td>
    </tr>
    <tr>
      <td>`ST`</td>
      <td>
        A [=shape tree=] that will no longer manage <code>TC</code>
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>NONE</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform a HEAD on Target Container <code>TC</code>
	<figure id="fig-unplant-container-head-request">
		<figcaption>Discover Target Container Shape Tree Metadata URI -
    Request</figcaption>
		<pre highlight="http">
		HEAD /data/CommonNotes/
		</pre>
	</figure>

	<figure id="fig-unplant-container-head-response">
		<figcaption>Discover Target Container Shape Tree Metadata URI -
    Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 200 OK
		Link: &lt;/data/CommonNotes/meta/bc1b490a#loc&gt;; rel="http://shapetrees.org/#ShapeTreeLocator"
		...other headers omitted...
		</pre>
	</figure>

	Let <code>METAURI</code> be the URI of the shape tree metadata resource
    pertaining to <code>TC</code>.

1. Perform a GET on the Target Container's Shape Tree metadata (<code>METAURI</code>)
	<figure id="fig-unplant-container-get-metadata">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Request</figcaption>
		<pre highlight="http">
		GET /data/CommonNotes/meta/bc1b490a#loc
		</pre>
	</figure>

	<figure id="fig-unplant-container-get-response-managed">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Managed Response</figcaption>
		<pre highlight="turtle">
		PREFIX st: &lt;http://www.w3.org/ns/st#&gt;

		&lt;#loc&gt;
		  a st:ShapeTreeLocator ;
		  st:location [
		    st:hasRootShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
		    st:hasShapeTree &lt;http://commonnote.example/commonnote#container-tree&gt; ;
		    st:hasShapeTreeInstanceRoot &lt;/data/CommonNotes/&gt; ;
		    st:node &lt;/data/CommonNotes/Note1#doc&gt; ;
		    st:shape &lt;http://commonnote.example/schema#NotesContainer&gt; ;
		  ]
		.
		</pre>
	</figure>

	<figure id="fig-unplant-container-get-response-unmanaged">
		<figcaption>Dereference Target Container Shape Tree Metadata URI -
    Unmanaged Response</figcaption>
		<pre highlight="http">
		HTTP/1.1 404 NOT FOUND
		</pre>
	</figure>

    If a 404 is returned that indicates that no shape trees manage this container.
    Let <code>EG</code> be the existing metadata graph resulting from dereferencing
    and parsing <code>METAURI</code>.

1. Remove pertinent shape tree triples

    Let <code>S</code> be the subject of type
    <code class="vocab">ShapeTreeLocator</code> with a
    <code class="vocab">st:hasShapeTree</code> matching <code>ST</code>.

    Remove the subject <code>S</code> along with the
    <code class="vocab">st:hasShapeTreeLocator</code> referencing <code>S</code>
    from the metadata graph.

1. Persist the updated graph to <code>METAURI</code>.


Describing Shape Trees {#describing}
=====================

While the RDF structure of [=shape trees=] enable machine readability, additional
context is needed to make it human-friendly.

External [=SKOS graphs=] can be <em class="rfc2119">OPTIONALLY</em> linked to
describe the shape tree in human-readable terms.

* Let <code>STR</code> be an RDF document containing one or more
    [=shape trees=] <code>STs</code>.
* The { &lt;&gt; <code class="vocab">st:hasShapeTreeDecoratorIndex</code>
    <code>IDX</code> } [=arc=] indicates that there is exactly one
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> located at
    <code>IDX</code>.
* The { <code>IDX</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> } [=arc=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorIndex</code> that represents an
    index of <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>IDX</code> <code class="vocab">st:hasSet</code>
    <code>SET</code> } [=arc=] indicates linkage to one or more
    <code class="vocab">st:ShapeTreeDecoratorSet</code>.
* The { <code>SET</code> <code>a</code>
    <code class="vocab">st:ShapeTreeDecoratorSet</code> } [=arc=] indicates a
    <code class="vocab">st:ShapeTreeDecoratorSet</code> that represents a
    [=SKOS graphs=] for a given language or interpretation.
* The { <code>SET</code> <code class="vocab">st:hasShapeTreeDecoratorResource</code>
    <code>DECRESOURCE</code> } [=arc=] indicates linkage to a single
    <code class="vocab">st:ShapeTreeDecoratorResource</code>.
* The { <code>SET</code> <code class="vocab">st:usesLanguage</code>
    <code>LANG</code> } [=arc=] indicates the language used by the associated
    <code>DECRESOURCE</code>.

<figure id="shapetree-decorator-shex">
  <figcaption>ShEx validation of a Shape Tree Decorators</figcaption>
  <pre highlight="turtle">
  PREFIX st: &lt;http://www.w3.org/ns/st#&gt;
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
  PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;
  PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

  &lt;#DecoratorIndex&gt; {
    a [ st:ShapeTreeDecoratorIndex ] ;
    st:defaultLanguage xsd:language ? ;
    st:hasSet IRI*
  }

  &lt;#DecoratorSet&gt; {
    a [ st:ShapeTreeDecoratorSet ] ;
    st:usesLanguage xsd:language ;
    st:hasShapeTreeDecoratorResource IRI
  }

  &lt;#Decorator&gt; {
    a [ st:ShapeTreeDecorator ] ;
    st:hasShapeTree IRI ;
    skos:prefLabel xsd:string ;
    skos:definition xsd:string ?
  }
  
  </pre>
</figure>    

SKOS constructs such as <code>skos:narrower</code> <em class="rfc2119">MAY</em>
  be used to group or organize related [=shape trees=].

Definitions {#definitions}
=====================
The following terms are used throughout this specification:
  * <dfn>Arc</dfn> -- the directed relationship between two nodes in an RDF graph
  * <dfn>Client-side Agent</dfn> -- A software component interacting with a server.
        in the context of shape trees, a client-side agent may be responsible for
        data validation.
  * <dfn>Container</dfn> -- the generalized notion of a collection of resources;
        implementations of [=shape trees=] <em class="rfc2119">MAY</em> use a
        container implementation such as [[LDP]]
        (ldp:Container, ldp:BasicContainer, etc.)
  * <dfn>Ecosystem</dfn> -- a software environment with resources organized in
        some hierarchical grouping that rely on [=shape tree=] concepts to
        better organize and validate structures of data
  * <dfn>Focus Node</dfn> -- the IRI to an RDF subject which is used to
        specify which subject within a document should be processed first.  In
        the context of [=shape trees=] one usage is directing [=shape=] validation
        to the appropriate node in the graph.
  * <dfn>Managed Container</dfn> -- any [=container=] that has a [=shape tree=]
        planted in it. A [=Managed Container=] <em class="rfc2119">MAY</em>
        be an [=Instance Root=] or hierarchically nested within the
        resource hierarchy.
  * <dfn>Non-RDF Source</dfn> -- the generalized notion of document not
        containing linked-data triples; this may include
        plain text or binary data.
  * <dfn>RDF</dfn> -- Resource Description Framework [[rdf11-primer]]
  * <dfn>Resource</dfn> -- the generalized notion of document containing linked-data;
        implementations of [=shape trees=] may use a resource implementation such
        as [[LDP]] (ldp:Resource, etc.)
  * <dfn>Server-side Agent</dfn> -- A server-side software component.  Server-side
        agents that support shape trees are responsible for data validation.
  * <dfn>Shape</dfn> -- a schema definition allowing validation of an RDF
        subject.  Example specifications supporting the notion of shapes include 
        [[ShEx]] and [[SHACL]].
  * <dfn>SKOS Graph</dfn> -- an RDF graph conforming to [[skos-reference]]
        data model.  For purposes of [=shape trees=] a
        [=SKOS Graph=] is used to describe a [=shape tree=] in
        human-readable terms.
  * <dfn>Unmanaged Container</dfn> -- any [=Container=] which is not described
        by a shape tree

  <pre class="biblio">
  {
    "ldp": {
      "href": "https://www.w3.org/TR/ldp/",
      "title": "Linked Data Platform 1.0",
      "authors": [
        "Steve Speicher",
        "John Arwe",
        "Ashok Malhotra"
      ]
    },
    "solid": {
          "href": "https://solidproject.org/TR/protocol",
          "title": "Solid Protocol",
          "authors": [
            "Sarven Capasdisli",
            "Tim Berners-Lee",
            "Kjetil Kjernsmo",
            "Justin Bingham",
            "Ruben Verborgh",
            "Dmitri Zagidulin"]
    },
    "rdf": {
          "href": "https://www.w3.org/TR/rdf11-concepts",
          "title": "RDF 1.1 Concepts and Abstract Syntax",
          "authors": [
            "Richard Cyganiak",
            "David Wood",
            "Markus Lanthaler"
          ]
        },
    "shex": {
      "href": "http://shex.io/shex-semantics/index.html",
      "title": "Shape Expressions Language 2.1",
      "authors": [
        "Eric Prud'hommeaux",
        "Iovka Boneva",
        "Jose Emilio Labra Gayo",
        "Gregg Kellogg"
      ]
    },
    "shexpath": {
      "href": "https://shexspec.github.io/spec/ShExPath",
      "title": "Shape Expressions ShExPath Language",
      "authors": [
        "Eric Prud'hommeaux"
      ]
    }
  }
  </pre>
