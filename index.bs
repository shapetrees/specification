<pre class="metadata">
Title: Shape Trees Specification
Shortname: shapetrees-spec
Level: 1
Max ToC Depth: 2
Status: w3c/ED
Group: w3c
URL: https://shapetrees.org/TR/specification/
Editor: Eric Prud'hommeaux
Editor: Justin Bingham
Markup Shorthands: markdown yes
Abstract:
    Semantic Web Applications interoperate by sharing semantics of terms and
    constellations of resource-oriented data structures. This specification
    defines shape trees, a mechanism for declaring and operating over
    constellations of resource-oriented data structures.
</pre>

<!-- For bikeshed style overrides -->
<style>

  em.rfc2119 {
    text-transform: lowercase;
    font-variant: small-caps;
    font-style: normal;
    font-size: 18px;
    color: #900;
  }

  figcaption {
    text-align: left;
  }

  pre {
    font-size: 12px;
  }

  a[href*=".ttl"] {
    color: #339966;
    border-bottom: 1px solid #339966;
  }

  a[href*=".shex"] {
    color: #cc2900;
    border-bottom: 1px solid #cc2900;
  }

  a[href*=".tree"] {
    color: #e68a00;
    border-bottom: 1px solid #e68a00;
  }

  a[data-link-type=dfn] {
    color: #000000;
  }

  table.tree thead tr {
    font-size: 14px;
  }
  
  table.tree tbody tr:nth-child(even) {
    background-color: lightgray;
    font-size: 14px;
  }
  
  table.tree tbody td {
    font-size: 12px;
  }

  table.operation {
    border-collapse: separate;
    border: 3px solid #808080;
    margin-bottom: .5em;
  }

  table.operation thead tr {
    font-size: 14px;
  }

  table.operation thead th {
    background-color: #005A9C;
    color: #FFF;
  }

  table.operation th[colspan] {
    text-align: left;
  }

  table.operation td[colspan] {
    text-align: left;
  }

  table.operation tbody td {
    font-size: 13px;
    text-align: left;
  }

  table.operation code {
    background-color: #DCDCDC;
    color: #000;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;  
  }

  .opdetails code {
    background-color: #DCDCDC; 
    color: #000;
    font-weight: bold;
    font-size: 13px;
    padding-left: .2em;
    padding-right: .2em;
    padding-top: .05em;
    padding-bottom: .05em;
  }

  .opdetails code.vocab {
    color: #339966;
    background-color: #FFFFFF;
  }

  .opdetails ol {
    margin-left: 0;
    padding-left: 1em;
  }

	code.container {
		color: #005555;
	}

	code.notes {
		color: #770033;
	}

	code.citation {
		color: #330077;
	}

	code.image {
		color: #337700;
	}

    code.vocab {
		color: #339966;
	}
</style>

<div boilerplate="copyright">
  <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2020
  <a href="https://www.w3.org/">W3C</a>®
  (<a href="https://www.csail.mit.edu/">MIT</a>,
   <a href="https://www.ercim.eu/">ERCIM</a>,
   <a href="https://www.keio.ac.jp/">Keio</a>,
   <a href="https://ev.buaa.edu.cn/">Beihang</a>).
   W3C
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>,
   <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and
   <a href="https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document">permissive document license</a>
   rules apply.
</div>

Introduction {#introduction}
=====================

*This section is non-normative.*

Realizing the value proposition of the Semantic Web lies in building useful and
robust applications that can interoperate over linked data. Protocols such as
[[LDP]] and [[Solid]] organize linked data graphs into resource hierarchies,
providing a foundation upon which these robust and interoperable applications
can be created.

Application interoperability depends on applications sharing semantics for
relationships and data structures.  Existing technologies fulfill portions
of those dependencies:
* [[RDF]]&apos;s foundation in unambiguous identifiers provides an infrastructure
    that allows for interoperability, but does not specifically encourage or enforce it.
* [=Shape=] languages (e.g. [[ShEx]] and [[SHACL]]) provide machine-readable,
    enforceable data structure definitions on single resources.

For applications that operate on more complex and interconnected resources,
<i>[=Shape Trees=]</i> express the layout of those resources and associate them
with their respective [=shapes=].

[=Shape trees=] marry [[RDF]] vocabularies, shapes, and resources into
"little trees" that provide machine to machine interoperability, combining them
into concepts that humans can easily comprehend, such as medical records, notes,
notebooks, calendars, and financial records.

This allows one to treat a set of related resources as a single grouping, and
apply that to a range of operations including access control, data organization,
data validation, and data migration.

While [=shape trees=] are intended to adapt to different technology platforms
that support the notion of [=containers=] and [=resources=], examples in this
specification will reflect usage in an [[LDP]] environment.

[=Shape trees=] are defined as an [=RDF=] graph structure that expresses a set
of expected behaviors by agents that work with them. This provides a sort of
type-safety of resource hierarchies called <dfn>shape tree consistency</dfn>.
These semantics CAN be implemented by a [=server-side agent=], or by a
[=client-side agent=] that implements [=shape tree=] operations as primitive
requests to a server.

[=Shape tree=] support by a [=server-side agent=] ensures [=shape tree
consistency=] by managing all manipulations of data within a resource hierarchy
(see [=managed resource=]).

## ShapeTree Support From Proxy or Client-side Library

If a server does not support [=shape trees=], some [=shape tree consistency=]
can be achieved by implementing [=shape tree=] support in the client, typically
in a library than can enforce consistency for any clients using the
library. Primitive operations by other clients not using the library may leave the
resource hierarchy in an inconsistent state.

For client-side shape tree libraries that operate by intercepting HTTP
operations, this specification serves as an API for those client
interactions. (Additionally, if [=shape tree=] support is later added to the
server, the client's execution of [=shape tree=] operations does not change.) In
the remainder of this document, [=shape tree=] operations are described in terms
of a [=client-side agent=] performing operations on a [=server-side agent=] with
support for [=shape trees=].

A proxy performing [=shape tree=] operations would be indistinguishable from
server support except that clients performing primitive operations directly on
the server (bypassing the proxy) may leave the server in an inconsistent state.

Shape Tree {#tree}
=====================

A <dfn>shape tree</dfn> is a machine-readable template describing the 
expected layout of a tree of resources in a [=container=]-based [=ecosystem=].
A [=shape tree=] expresses a tree hierarchy by containing
other [=shape trees=]. The terms used to express a [=shape tree=] are described 
using an [[RDF]] [vocabulary](shapetrees.ttl).

A <dfn>managed instance</dfn> is a resource assigned to 
and in conformance with one or more [=shape trees=] via 
a [=shape tree manager=]. The primary resource in a
[=managed instance=] is called a <dfn>managed resource</dfn>.

Every [=managed resource=] has an associated [=shape tree manager=].
A [=shape tree manager=] identifies the [=shape tree=] associated
with a [=managed resource=], and additional information needed to navigate 
nested hierarchies of managed resources. A resource becomes a 
[=managed resource=] when a [=shape tree manager=] is associated with it 
through the [[#plant-shapetree]] operation.

The <code class="vocab">st:expectsType</code> property of a [=shape tree=] 
specifies that the described [=managed resource=] be one of these three types:

<table class="data" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <tbody>
    <tr>
      <td><code class="vocab">st:Resource</code></td>
      <td>Regular RDF resource that is not a container</td>
    </tr>
    <tr>
      <td><code class="vocab">st:Container</code></td>
      <td>RDF resource that uses server-managed metadata to
      enumerate nested resources</td>
    </tr>
    <tr>
      <td><code class="vocab">st:NonRDFResource</code></td>
      <td>Non-RDF resource such as binaries or images</td>
    </tr>
  </tbody>
</table>

The <code class="vocab">st:shape</code> property specifies that the 
described [=managed resource=] conforms to the stated [[ShEx]] or [[SHACL]] 
shape.

[=Shape trees=] prescribe physical hierarchies and can reference other
shape trees to form virtual hierarchies. 

For physical hierarchies, the <code class="vocab">st:contains</code>
property asserts that a [=managed resource=] is a [=container=] that
explicitly contains another [=managed resource=].

If [=shape tree=] `S1` <code class="vocab">st:contains</code> [=shape tree=] 
`S2`, `S1` describes a [=container=] that contains another [=managed resource=] 
described by `S2`. For example, in [[LDP]], `S1` describes 
an [[LDP]] [=container=] which <code class="vocab">ldp:contains</code> nested 
resources described by `S2`. [=Shape tree=] `S2` and the nested resources 
associated with it are considered to be <dfn>in-scope</dfn> of the containing 
[=shape tree=] `S1`.

<figure id="shapetree-physical">
  <figcaption>Shape tree validation of a physical hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1/`</td>
        <td>`ex:ProjectTree`</td>
      </tr>
      <tr>
        <td>`-- /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
      </tr>
      <tr>
        <td>`---- /task-43/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /task-48/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-aa89`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`---- /task-61/`</td>
        <td>`ex:TaskTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-cd12`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`------ /attachment-ef55`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`---- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
      </tr>
    </tbody>
  </table>

  <pre class=include-code>
    path: snippets/project-tree.ttl
    highlight: turtle
    show: 1-29
  </pre>

</figure>

A virtual hierarchy is defined by [=shape tree references=] that link to
other [=shape trees=] by the <code class="vocab">st:references</code>
property.
A <dfn>shape tree reference</dfn> 
identifies the [=shape tree=] to be referenced via 
<code class="vocab">st:referencesShapeTree</code>, and the [=shape path=] through 
which it is linked via either <code class="vocab">st:viaShapePath</code>, or
<code class="vocab">st:viaPredicate</code>.

A <dfn>shape path</dfn> is a string that defines a traversal 
of a [=shape=] schema. [[SHEXPATH]]

<figure id="shapetree-virtual">
  <figcaption>Shape tree validation of a virtual hierarchy</figcaption>
  <table class="data tree" align="left">
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Associated Shape Tree</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/project-1`</td>
        <td>`ex:VirtualProjectTree`</td>
      </tr>
      <tr>
        <td>`/milestone-A`</td>
        <td>`ex:VirtualMilestoneTree`</td>
      </tr>
      <tr>
        <td>`/task-43`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/task-48`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/attachment-aa89`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/task-61`</td>
        <td>`ex:VirtualTaskTree`</td>
      </tr>
      <tr>
        <td>`/issue-22`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
      <tr>
        <td>`/attachment-cd12`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/attachment-ef55`</td>
        <td>`st:NonRDFResourceTree`</td>
      </tr>
      <tr>
        <td>`/issue-31`</td>
        <td>`ex:VirtualIssueTree`</td>
      </tr>
    </tbody>
  </table>

  <pre class=include-code>
    path: snippets/project-tree.ttl
    highlight: turtle
    show: 31-70
  </pre>

</figure>

Let <code>ST</code> be a [=shape tree=]. 
Let <code>STI</code> be a corresponding [=managed instance=].

* An { `ST` <code class="vocab">st:expectsType</code> `T` } [=triple=] identifies
    the resource type `T` of a  corresponding [=managed resource=] 
    <code>R</code> in <code>STI</code> 
    where `T` <em class="rfc2119">MUST</em> be one of
    <code class="vocab">st:Resource</code>,
    <code class="vocab">st:Container</code>, or
    <code class="vocab">st:NonRDFResource</code>.
* An { `ST` <code class="vocab">rdfs:label</code> `L` } [=triple=]
    indicates that there is at most one corresponding [=managed resource=] 
    `R` in `STI` and it has the name `L`. `L` is a <dfn>static resource</dfn>.
* An { `ST` <code class="vocab">st:shape</code> `SH` }
    [=triple=] indicates that [=managed resource=] `R` has
    at most one node which conforms to [=shape=] `SH`.
* An { `ST` <code class="vocab">st:contains</code> `ST2` }
    [=triple=] identifies a nested [=shape tree=] `ST2`.
* An { `ST` <code class="vocab">st:references</code> `STR` }
    [=triple=] indicates that the [=shape tree=] identified in
    [=shape tree reference=] `STR`, is referenced through the
    instance data of `STI`.
    * An { `STR` <code class="vocab">st:referencesShapeTree</code> `ST3` } [=triple=]
        indicates a [=shape tree=] referenced through the instance data of `STI`
    * An { `STR` <code class="vocab">st:viaShapePath</code> `PATH` } 
        [=triple=] identifies the [=shape path=] through which a
        [=managed instance=] of `ST3` can be found via the instance data of
        `STI`
    * An { `STR` <code class="vocab">st:viaPredicate</code> `PRED` }
        [=triple=] identifies the RDF predicate through which a
        [=managed instance=] of `ST3` can be found via the instance data of
        `STI`

## Shape Tree Schema ## {#st-schema}

<figure id="shapetree-shex">
  <figcaption>ShEx Schema for a Shape Tree</figcaption>
  <pre class=include-code>
  path: shapetrees-schema.shex
  highlight: turtle
  show: 7-28
  </pre>
</figure>

Assigning Shape Trees {#assigning}
=====================

## Shape Tree Manager ## {#manager}

A <dfn>shape tree manager</dfn> associates a [=managed resource=] with 
one or more [=shape trees=]. No more than one [=shape tree manager=] may be
associated with a [=managed resource=]. 

A [=shape tree manager=] includes one or more [=shape tree assignments=].

The server MUST advertise the URI of the [=shape tree manager=] for a 
given resource by responding to HTTP requests of that resource with an
included `HTTP Link` header with a `rel` value of 
`http://www.w3.org/ns/shapetrees#managedBy` and the manager resource
as the link target.

Conversely, the server MUST advertise the URI of the resource managed
by a [=shape tree manager=] by responding to HTTP requests of the
manager resource with an included `HTTP Link` header with a `rel` value of
`http://www.w3.org/ns/shapetrees#manages` and the [=managed resource=]
as the link target.

<figure id="shapetree-manager-properties">
  <figcaption>Shape Tree Manager properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:hasAssignment</code></td>
        <td>Links a [=shape tree assignment=] of the [=shape tree manager=]</td>
      </tr>
    </tbody>
  </table>
</figure>

## Shape Tree Assignment ## {#assignment}

A <dfn>shape tree assignment</dfn> is used to associate a given [=shape tree=]
with a [=managed resource=]. 

[=Shape tree assignments=] identify key contextual points in a physical 
hierarchy. A <dfn>root shape tree assignment</dfn> is set by the 
[Plant Operation](#plant-shapetree), and any subsequent assignment applied
within that managed hierarchy reference it via `st:hasRootAssignment`.

If there is more than one [=shape tree assignment=] in a [=shape tree manager=], 
they must all apply to the same [=managed resource=] associated with the 
[=shape tree manager=].

<figure id="shapetree-assignment-properties">
  <figcaption>Shape Tree Assignment properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:assigns</code></td>
        <td>Identifies the [=shape tree=] to be associated with 
        the [=managed resource=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:manages</code></td>
        <td>Identifies the [=managed resource=] associated with the [=shape tree assignment=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:hasRootAssignment</code></td>
        <td>Identifies the [=root shape tree assignment=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:focusNode</code></td>
        <td>Identifies the focus node for [=shape=] validation 
        in the associated [=managed resource=], and is only valid when the 
        corresponding [=shape tree=] includes 
        <code class="vocab">st:shape</code></td>
      </tr>    
      <tr>
        <td><code class="vocab">st:shape</code></td>
        <td>Identifies the [=shape=] to which <code class="vocab">st:focusNode</code> 
        must conform, and must be equivalent to <code class="vocab">st:shape</code>
        in the corresponding [=shape tree=]</td>
      </tr>
    </tbody>
  </table>
</figure>
  
A [=root shape tree=], and its corresponding [=managed resource=] can
be planted within an existing managed hierarchy, alongside or within other
[=root shape trees=] and [=managed resources=].

[=Shape tree assignments=]
in a given [=shape tree manager=] may have different
focus nodes.

<figure id="shapetree-navigation">
  <figcaption>Navigating a physical shape tree hierarchy</figcaption>
  <table class="data tree" align="left">
    <colgroup>
    <colgroup>
    <col>
    <col>
    <col>
    <thead>
      <tr>
        <th>Managed Resource</th>
        <th>Shape Tree</th>
        <th>Root Shape Tree</th>
        <th>Root Managed Resource</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>`/data/`</td>
        <td>`ex:DataTree`</td>
        <td>`ex:DataTree`</td>
        <td>`/data/`</td>
      </tr>
      <tr>
        <td>`-- /projects/`</td>
        <td>`ex:DataCollectionTree`<br/>
            `ex:ProjectCollectionTree`</td>
        <td>`ex:DataTree`<br/>
            `ex:ProjectCollectionTree`</td>
        <td>`/data/`<br/>
            `/data/projects/`</td>
      </tr>
      <tr>
        <td>`---- /project-1/`</td>
        <td>`ex:ProjectTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`------ /milestone-A/`</td>
        <td>`ex:MilestoneTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-43/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-48/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-aa89`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /task-61/`</td>
        <td>`ex:TaskTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-22/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-cd12`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`---------- /attachment-ef55`</td>
        <td>`ex:AttachmentTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
      <tr>
        <td>`-------- /issue-31/`</td>
        <td>`ex:IssueTree`</td>
        <td>`ex:ProjectCollectionTree`</td>
        <td>`/data/projects/`</td>
      </tr>
    </tbody>
  </table>
</figure>

<figure id="manager-multiple-assignments">
  <figcaption>[=Shape Tree Manager=] for /data/projects/ with multiple 
    [=shape tree assignments=] in a nested physical hierarchy</figcaption>
  <pre class=include-code>
    path: snippets/manager-multiple.ttl
    highlight: turtle
    show: 1-25
  </pre>
</figure>

<figure id="manager-single">
  <figcaption>[=Shape Tree Manager=] for 
    /data/projects/project-1/milestone-A/task-48 with a single 
    [=shape tree assignment=] in a nested physical hierarchy</figcaption>
  <pre class=include-code>
    path: snippets/manager-single.ttl
    highlight: turtle
    show: 1-20
  </pre>
</figure>

## Shape Tree Manager Schema ## {#st-manager-schema}

<figure id="shapetree-manager-shex">
  <figcaption>ShEx Schema for a Shape Tree Manager</figcaption>
  <pre class=include-code>
  path: shapetrees-schema.shex
  highlight: turtle
  show: 37-49
  </pre>
</figure>

Shape Tree Operations {#operations}
=====================

Working with [=shape trees=] entails using several higher-level operations --
each of which may represent one or more HTTP requests and/or pieces of
processing logic.

In regular use, a [=client-side agent=] manipulates resources on a 
[=resource server=] running a [=server-side agent=]. That [=server-side agent=] 
applies logic for [=shape tree=] validation and navigation where applicable
when processing requests from [=client-side agents=]. 

The key operations used to manage [=shape trees=] are:
* [Discover Shape Tree](#discover) - determine the [=shape tree=] linked to some [=managed resource=].
* [Plant Shape Tree](#plant-shapetree) - declare that a resource will henceforth be managed by the provided [=shape tree=].
* [Unplant Shape Tree](#unplant-shapetree) - assert that a managed resource should no longer be managed by the provided [=shape tree=].
* [Create Managed Instance](#create-managed-instance) - add a resource to a managed resource hierarchy.
* [Update Managed Instance](#update-managed-instance) - modify a resource in a managed resource hierarchy.
* [Delete Managed Instance](#delete-managed-instance) - remove a resource in a managed resource hierarchy.

These operations make use of reusable, internal algorithms defined in
[Shape Tree Algorithms](#algorithms).

[=Shape tree=] logic can be applied by [=server-side agents=]
implementing different protocols such as [[LDP]] or [[Solid]]. The operations
defined herein defer to the implementing protocol as to the appropriate
status code and composition of HTTP responses.

Note: Server-side processing of changes to [=shape tree managers=]
can support the addition and removal of multiple [=shape tree assignments=]
at once. For simplicity, this specification provides discreet client-side
operations to plant or unplant one shape tree at a time. However, it
would not be inappropriate to provide client implementations that
support requests to plant and unplant multiple shape trees for a 
given [=resource=] in a single request.

## Discover Shape Tree ## {#discover}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation is used by a [=client-side agent=] to discover  
        any [=shape trees=] associated with a given [=resource=].
        
        If `URI` is a [=managed resource=], the associated 
        [=Shape Tree Manager=] will be returned.  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESOURCEURI`</td>
      <td>The URI of the resource to discover shape trees for</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`MANAGER`</td>
      <td>[=Shape tree manager=] associated with the [=managed resource=]</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP HEAD or GET on the provided <code>RESOURCEURI</code>.  

<pre highlight="http">
  HEAD https://storage.example/data/projects/
</pre>

<pre highlight="http">
  HTTP/1.1 200 OK
  Link: &lt;https://storage.example/meta/c560224b&gt;; rel="http://www.w3.org/ns/shapetrees#managedBy"
  Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel="type"
  ...other HTTP response headers omitted...
</pre>

2. Let <code>MANAGERURI</code> be the URI of a [=shape tree manager=] 
    associated with `RESOURCEURI` with a Link relation type of 
    `http://www.w3.org/ns/shapetrees#managedBy`.
   
3. If `MANAGERURI` is missing, the resource at 
    `RESOURCEURI` is not a [=managed resource=], and no [=shape tree manager=] 
    will be returned.
   
4. Perform an HTTP GET on `MANAGERURI`

<pre highlight="http">
  GET https://storage.example/data/projects/.shapetree
</pre>

<pre highlight="turtle">
  ...HTTP response headers omitted...
  PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
  PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
  PREFIX ex: &lt;http://www.example/ns/ex#&gt;

  &lt;&gt;
    a st:Manager ;
    st:hasAssignment <#assignment1> .
    
  <#assignment1>
    st:assigns ex:DataCollectionTree ;
    st:manages &lt;https://storage.example/data/projects/&gt;
    st:hasRootAssignment &lt;https://storage.example/data/.shapetree#assignment1&gt; ;
    st:focusNode &lt;https://storage.example/data/projects/#collection&gt; ;
    st:shape ex:DataCollectionShape .
</pre>

5. If a corresponding resource at `MANAGERURI` is not found, it 
    <em class="rfc2119">MUST</em> be considered
    an [=unmanaged resource=].

<pre highlight="http">
GET https://storage.example/data/projects/.shapetree
</pre>

<pre highlight="http">
HTTP/1.1 404 Not Found
</pre>

5. If `MANAGERURI` contains a valid [=shape tree manager=],
    the resource at `RESOURCEURI` <em class="rfc2119">MUST</em> be considered a 
    [=managed resource=].

</div>

## Plant Shape Tree ## {#plant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation marks an existing [=resource=] as managed by 
        one or more shape trees, by creating or updating an associated 
        [=shape tree manager=]. 

        If the 
        [=resource=] is already managed, the associated [=shape tree manager=]
        will be updated with another [=shape tree assignment=] for the 
        planted [=shape tree=].

        If the [=resource=] is a container that already contains existing
        resources, this operation will perform a depth first traversal through 
        the containment hierarchy, validating and assigning as it works its 
        way back up to the target resource of this operation.

      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#plant-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the resource to plant on</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the shape tree to plant for `TR`</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the 
      subject within `TR` used as the focus node for shape validation</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. [Discover](#discover) if `TR` is a [=managed resource=]. 
    * Let `MANAGERURI` be the URI of the [=Shape Tree Manager=] associated 
        with `TR`.
1. Perform an HTTP `PUT` or `PATCH` on `MANAGERURI` to create or update the 
    [=Shape Tree Manager=] for `TR`
    * Add a new `st:Assignment ASN`  
      * Let `ASN assigns` be `TST`
      * Let `ASN manages` be `TR`      
      * Let `ASN hasRootAssignment` be `ASN`
      * If `TST` has an `st:shape`
          * Let `ASN st:shape` be the object value of `TST st:shape`
          * Let `ASN st:focusNode` be `FN`

</div>

<pre highlight="http">
PUT https://storage.example/data/projects/.shapetree
</pre>
<pre highlight="turtle">
PREFIX st: &lt;http://www.w3.org/ns/shapetrees#&gt; 
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;  
PREFIX ex: &lt;http://www.example/ns/ex#&gt;

&lt;&gt;
  a st:Manager ;
  st:hasAssignment <#assignment1>, <#assignment2> .
  
<#assignment1>
  st:assigns ex:DataCollectionTree ;
  st:manages &lt;https://storage.example/data/projects/&gt;
  st:hasRootAssignment &lt;https://storage.example/data/.shapetree#assignment1&gt; ;
  st:focusNode &lt;https://storage.example/data/projects/#collection&gt; ;
  st:shape ex:DataCollectionShape .

<#assignment2>
  st:assigns ex:ProjectCollectionTree ;
  st:manages &lt;https://storage.example/data/projects/&gt;
  st:hasRootAssignment &lt;https://storage.example/data/projects/.shapetree#assignment2&gt; ;
  st:focusNode &lt;https://storage.example/data/projects/#collection&gt; ;
  st:shape ex:ProjectCollectionShape .
</pre>

<pre highlight="http">
HTTP/1.1 204 No Content
</pre>

### [=Server-side Agent|Server-side=] ### {#plant-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `PUT` or `PATCH` request on `MANAGERURI` from the 
    [[#plant-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

Note: The following sequence is invoked by the server in response 
to the `HTTP PUT` or `HTTP PATCH` on `MANAGERURI` by the [=client-side agent=] 
in the [[#plant-client|previous sequence]].

1. Let `MANAGER` be the [=shape tree manager=] target of `REQ`
1. Let `R` be the primary resource directly associated with `MANAGER`
1. Let `UMR` be the updated [=shape tree manager=] in the body of `REQ`
1. Let `EMR` be the existing [=shape tree manager=] resource on the server
1. Let `ADDED` be the set of [=shape tree assignments=] that have been added to `EMR` by `UMR`
1. Let `REMOVED` be the set of [=shape tree assignments=] that have been removed from `EMR` by `UMR`
1. If `REMOVED` is not empty, the server must [[#unplant-server|unplant]] the
    [=shape tree assignments=] that have been removed.
1. For each [=shape tree assignment=] `ASN` in `ADDED`
    1. Call [[#assign-resource]]  with inputs: `UMR`, `ASN`, `ASN`, `R`, `NULL`

</div>

## Unplant Shape Tree ## {#unplant-shapetree}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation unassigns a planted 
        [=shape tree=] from a given [=managed resource=]. If the
        [=managed resource=] is a [=managed container=], it will also
        unassign contained resources. 

        This operation will fail immediately if the [=shape tree=] to unplant 
        is not the root [=shape tree assignment=].
      </td>
  </tbody>
</table>

### [=Client-side Agent|Client-side=] ### {#unplant-client}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=managed resource=] to unplant</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>A URI representing the target shape tree to unplant for `TR`</td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `MANAGER` be the [=Shape Tree Manager=] returned from [[#discover]] 
    with inputs: `TR`

1. Return failure if `MANAGER` has zero or more than one
    [=shape tree assignments=] where `st:assigns` is `TST`
   
1. If `MANAGER` has a single [=shape tree assignment=]
    1. Perform an HTTP `DELETE` on `MANAGER` to fully remove the
        [=Shape Tree Manager=] for `TR`

<pre highlight="http">
DELETE https://storage.example/data/projects/.shapetree
</pre>
<pre highlight="http">
HTTP/1.1 204 No Content
</pre>


1. If `MANAGER` has more than one [=shape tree assignment=]
    1. Let `ASN` be the [=shape tree assignment=] where `st:assigns` is `TST`
    1. Perform an HTTP `PUT` or `PATCH` on `MANAGER` to remove `ASN`

</div>

### [=Server-side Agent|Server-side=] ### {#unplant-server}

<table class="data operation" align="left">
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>
        An HTTP PUT, PATCH, or DELETE request on the [=shape tree manager=]
        `MANAGER` from the [[#unplant-client|previous sequence]].
      </td>
    </tr> 
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A standard HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

Note: The following sequence is invoked by the server in response
to the `HTTP PUT`, `HTTP PATCH`, or `HTTP DELETE` on `MANAGERURI` by the 
[=client-side agent=] in the [[#unplant-client|previous sequence]].

1. Let `MANAGER` be the [=shape tree manager=] target of `REQ`
1. Let `R` be the primary resource directly associated with `MANAGER`
1. Let `UMR` be the updated [=shape tree manager=] in the body of `REQ`
1. Let `EMR` be the existing [=shape tree manager=] resource on the server
1. Let `ADDED` be the set of [=shape tree assignments=] that have been added to `EMR` by `UMR`
1. Let `REMOVED` be the set of [=shape tree assignments=] that have been removed from `EMR` by `UMR`
1. For each [=shape tree assignment=] `ASN` in `REMOVED`
  1. Call [[#unassign-resource]]  with inputs: `ASN`, `R`
1. If `ADDED` is not empty, the server must [[#plant-server|plant]] the
     [=shape tree assignments=] that have been added.

</div>

## Create Managed Instance ## {#create-managed-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation creates a [=managed instance=] within a 
        [=managed container=].

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#create-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target shape 
      tree associated with the created resource</td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>An <em class="rfc2119">OPTIONAL</em> URI representing the target 
      subject within `TR` used for shape validation</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `POST`, `PUT`, or `PATCH` in or on `TR` to create the
    [=managed instance=] including:
    * An HTTP `Link` header with the relation of 
        `http://www.w3.org/ns/shapetrees#TargetShapeTree` if `SHAPETREEURI` is provided
    * An HTTP `Link` header with the relation of 
        `http://www.w3.org/ns/shapetrees#FocusNode` if `FNURI` is provided

</div>

### [=Server-side Agent|Server-side=] ### {#create-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `POST`, `PUT`, or `PATCH` request in or on the [=target resurce=] `TR` 
      from the [[#create-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the proposed resource from `REQ`
1. Let `TST` be the value of an optionally provided HTTP `Link` header with 
    the relation of `http://www.w3.org/ns/shapetrees#TargetShapeTree`
1. Let `FN` be the value of an optionally provided HTTP `Link` header with
    the relation of `http://www.w3.org/ns/shapetrees#FocusNode`
1. Let `PC` be the parent [=container=] for `TR`
1. Let `CASN` be the [=shape tree assignment=] whose [=shape tree=] `CASNST` 
    manages the allowed members of `PC` via `CASNST st:contains`
    1. If `CASN` is not found, the request can be passed through, as the created
        resource `TR` will not be a [=managed resource=]
1. Call [[#validate-contained-resource]] with inputs: `CASNST`, `TR`, `TST`, `FN`
    1. Let `AVR` be the positive validation result returned
1. Create `TR`
1. Call [[#assign-resource]] with inputs: `NULL`, `CASN st:hasRootAssignment`, `CASN`, `TR`, `AVR` 

</div>

## Update Managed Instance ## {#update-managed-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation updates an existing [=managed resource=]. 

        Note: This operation can be performed as
        a standard HTTP operation with no knowledge of [=shape trees=].
        However, server-side processing is more efficient when
        the target shape tree and focus node for validation can be provided
        by the [=client-side agent=].
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#update-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `PUT` or `PATCH` on an existing resource `TR` to update the
     [=managed instance=]
   
</div>

### [=Server-side Agent|Server-side=] ### {#update-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>A HTTP `PUT` or `PATCH` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Let `UR` be the updated version of `TR` in the body of `REQ`
1. Let `MR` be the [=shape tree manager=] associated with `TR`
1. If `MR` exists
    1. For each [=shape tree assignment=] `ASN` in `MR`
        1. Call [[#validate-resource]] with inputs: `ASN st:assigns`, `UR`, `ASN st:focusNode` 
1. Update [=resource=] `TR` with `UR`

</div>

## Delete Managed Instance ## {#delete-managed-instance}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This operation deletes a [=managed resource=] for an existing 
        [=managed instance=]. 

        Note: This operation should be performed as
        a standard HTTP operation with no knowledge of [=shape trees=]. It
        is included here for completeness
      </td>
  </tbody> 
</table>

### [=Client-side Agent|Client-side=] ### {#delete-instance-client}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`TR`</td>
      <td>The URI of the target [=resource=]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Perform an HTTP `DELETE` on an existing resource `TR` to delete the
    [=managed instance=]

</div>

### [=Server-side Agent|Server-side=] ### {#delete-instance-server}

<table class="data operation" align="left">
<thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`REQ`</td>
      <td>An HTTP `DELETE` request on the [=managed resource=] 
      from the [[#update-instance-client|previous sequence]]</td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>A standard HTTP response</td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `TR` be the target resource of `REQ`
1. Delete [=resource=] `TR`
    * The [=Shape Tree Manager=] associated with `TR`
        <em class="rfc2119">MUST</em> be removed with `TR`

</div>

Shape Tree Algorithms {#algorithms}
=====================

The following algorithms define a library of functions referenced in the above
[operations](#operations).

## Assign Shape Tree to Resource ## {#assign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      Assigns the target [=shape tree=] `TST` to the target [=resource=] 
      resource `TR`.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RTMR`</td>
      <td>
        The root [=shape tree manager=] of the planted hierarchy 
      </td>
    </tr>
    <tr>
      <td>`RTASN`</td>
      <td>
        The root [=shape tree assignment=] of the planted hierarchy 
      </td>
    </tr>
    <tr>
      <td>`PASN`</td>
      <td>
        The parent [=shape tree assignment=] of the primary resource `R` 
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The primary resource for assignment 
      </td>
    </tr>
    <tr>
      <td>`AVR`</td>
      <td>
        An optional validation result indicating that that `R` has
        already passed validation in advance and does not need this algorithm 
        to perform validation again.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A regular HTTP Response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `ATPLANTROOT` be true if `RTASN st:manages` is `R` 
1. If `AVR` is provided
    1. Let `RST` be the [=shape tree=] that `R` has been validated to conform to
    1. Let `RFN` be the focus node for shape validation by `RST st:shape`
1. If `ATPLANTROOT`
    1. Let `RST` be `RTASN st:assigns`
    1. If `AVR` was not provided call [[#validate-resource]] with inputs: `RST`, `R`, `NULL`
    1. Let `RFN` be the matching focus node provided in the validation result
1. If not `ATPLANTROOT` and `AVR` was not provided
    1. Call [[#validate-contained-resource]] with inputs: `PASN st:assigns`, `R`, `RST`, `RFN`
    1. Let `RST` be the matching [=shape tree=] provided in the validation result
    1. Let `RFN` be the matching focus node provided in the validation result
1. Let `RMR` be the [=shape tree manager=] associated with `R`
1. Let `RASN` be a new [=shape tree assignment=] created for `R` with the following  properties:
    * Let `st:assigns` be `RST`
    * Let `st:manages` be `R`
    * Let `st:hasRootAssignment` be `RASN`
    * Let `st:focusNode` be `RFN`
    * Let `st:shape` be `RST st:shape`
1. If `R` is a non-empty container, let `CONTAINED` be the set of contained resources
    sorted by type, containers first. 
1. For each contained resource `CR` in `CONTAINED`, starting with containers
    1. Call [[#assign-resource]] with inputs: `RTMR`, `RTASN`, `RASN`, `R`, `NULL`
1. Create or Update the [=Shape Tree Manager=] `RMR`

</div>

## Unassign Shape Tree from Resource ## {#unassign-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2> 
      Unassigns a [=shape tree=] managing resource `R` by removing the
      [=shape tree assignment=] assigned to `R` for that [=shape tree=].
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RTASN`</td>
      <td>
        The root [=shape tree assignment=] at the top of the planted
        hierarchy.
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to unplant in the plant hierarchy of `RTASN` 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`RESPONSE`</td>
      <td>
        A regular HTTP response
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Let `RMR` be the [=shape tree manager=] associated with `R`
1. Let `RASN` be the [=shape tree assignment=] to remove for `R` where 
    `RTASN` is equivalent to `RASN st:hasRootAssignment`
1. Let `RASNST` be the [=shape tree=] `RASN st:assigns`
1. If `R` is a non-empty container, let `CONTAINED` be the set of contained resources
    sorted by type, containers first.
1. For each contained resource `CR` in `CONTAINED`, starting with containers
    1. Call [[#unassign-resource]] with inputs: `RTASN`, `CR`
1. Update or delete the [=Shape Tree Manager=] `RMR`
 
</div>

## Validate Contained Resource ## {#validate-contained-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
        This algorithm is responsible for determining which [=shape tree=] within a set
        of shape trees mentioned in <code class="vocab">st:contains</code> is
        applicable for a given proposed resource.
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`ST`</td>
      <td>
        The validating [=shape tree=]
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to be evaluated against the permitted set of contained 
        [=shape trees=] in `ST st:contains` 
      </td>
    </tr>
    <tr>
      <td>`TST`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI that provides the algorithm 
        with a target shape tree that `R` is expected to conform to. No 
        other [=shape trees=] from `ST st:contains` are considered when provided.
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">OPTIONAL</em> URI representing the target 
        subject node within `R` used for shape validation.
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`VR`</td>
      <td>
        A validation result containing:
        <ul>
          <li>Valid (true or false)</li>
          <li>Validating shape tree `ST`</li>
          <li>Matching shape tree in `ST st:contains`</li>
          <li>Matching shape (if applicable)</li>
          <li>Matching focus node (if applicable)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. If `TST st:contains` is empty, return a true validation result
1. If `TST` is provided but does not exist in `ST st:contains` return a false validation result
1. If `TST` is provided call [[#validate-resource]] with inputs: `TST`, `R`, `FN`    
1. If `TST` is not provided then for each [=shape tree=] `CST` linked via `ST st:contains`
    1. Call [[#validate-resource]] with inputs: `CST`, `R`, `FN`

</div>

## Validate Resource ## {#validate-resource}

<table class="data operation" align="left">
  <colgroup></colgroup>
  <colgroup></colgroup>
  <thead>
    <tr><th colspan=2>Description</th></tr>
  </thead>
  <tbody>
    <tr>
      <td colspan=2>
      This algorithm is responsible for determining whether a given resource
      conforms with a [=shape tree=]  
      </td>
  </tbody>
  <thead>
    <tr><th colspan=2>Inputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`ST`</td>
      <td>
        The [=shape tree=] that `R` will be evaluated against 
      </td>
    </tr>
    <tr>
      <td>`R`</td>
      <td>
        The resource to evaluate for conformance to `ST` 
      </td>
    </tr>
    <tr>
      <td>`FN`</td>
      <td>
        An <em class="rfc2119">Optional</em> focus node to use for shape 
        validation when `ST st:shape` is set 
      </td>
    </tr>
  </tbody>
  <thead>
    <tr><th colspan=2>Outputs</th></tr>
  </thead>
  <tbody>
    <tr>
      <td>`VR`</td>
      <td>
        A validation result containing:
        <ul>
          <li>Valid (true or false)</li>
          <li>Validating shape tree `ST`</li>
          <li>Matching shape (if applicable)</li>
          <li>Matching focus node (if applicable)</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<div class="opdetails">

1. Return a failing validation result if `ST st:expectedType` is set and is not the resource type of `R`
1. Return a failing validation result if `ST rdfs:label` is set and is not equal to the resource name of `R`
1. Return a failing validation result if `ST st:shape` is set and shape validation of the body content of `R` fails
1. Return a positive validation result

</div>

Describing Shape Trees {#descriptions}
=====================

## Shape Tree Description ## {#description}

While the RDF structure of [=shape trees=] enable machine readability, additional
context is needed to make it human-friendly. A <dfn>Shape Tree Description</dfn> 
provides a human-readable information
about a given [=shape tree=].

[=Shape tree descriptions=] are organized into [=shape tree description sets=].

<figure id="shapetree-description-properties">
  <figcaption>Shape Tree Description properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:describes</code></td>
        <td>Identifies the [=shape tree=] being described</td>
      </tr>
      <tr>
        <td><code class="vocab">st:inDescriptionSet</code></td>
        <td>Identifies the [=shape tree description set=] that the description
        belongs to</td>
      </tr>
      <tr>
        <td><code class="vocab">skos:prefLabel</code></td>
        <td>Provides a human readable name for the [=shape tree=]</td>
      </tr>
      <tr>
        <td><code class="vocab">skos:definition</code></td>
        <td>Provides a more in-depth, human readable description of the [=shape tree=]</td>
      </tr>
      <tr>
        <td><code class="vocab">st:describesInstance</code></td>
        <td>Identifies a predicate whose object value can be used to describe
        a [=managed instance=] of the described [=shape tree=]. The object 
        value must be a literal.</td>
      </tr>
      <tr>
        <td><code class="vocab">skos:narrower</code></td>
        <td>Identify a poly-hierarchy link between two [=shape tree descriptions=]
        in a [=shape tree description set=]</td>
      </tr>
      <tr>
        <td><code class="vocab">skos:broader</code></td>
        <td>Identify a poly-hierarchy link between two [=shape tree descriptions=]
        in a [=shape tree description set=]</td>
      </tr>
    </tbody>
  </table>
</figure>

<figure id="shapetree-description-shex">
  <figcaption>ShEx Schema for Shape Tree Description</figcaption>
  <pre class=include-code>
    path: shapetrees-schema.shex
    highlight: turtle
    show: 56-65
  </pre>
</figure>    

## Shape Tree Description Set ## {#description-set}

[=Shape tree descriptions=] are organized into a 
<dfn>Shape Tree Description Set</dfn>.

An RDF resource containing one or more [=shape trees=] can be 
<em class="rfc2119">OPTIONALLY</em> linked to
a [=shape tree description set=] to describe the contained shape trees in 
human-readable terms.

Each [=shape tree description set=] is made up of any number of 
[=shape tree descriptions=].

SKOS constructs such as <code>skos:narrower</code> and
<code>skos:broader</code> <em class="rfc2119">MAY</em>
be used to group or organize related [=shape trees=] in a given
[=shape tree description set=]

<figure id="shapetree-description-set-properties">
  <figcaption>Shape Tree Description Set properties</figcaption>
  <table class="data" align="left">
    <colgroup></colgroup>
    <colgroup></colgroup>
    <thead>
      <tr>
        <th>Property</th>
        <th>Description</th> 
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="vocab">st:usesLanguage</code></td>
        <td>Identifies the `xsd:language` utilized in the contained
        [=shape tree descriptions=]</td>
      </tr>
    </tbody>
  </table>
</figure>

<figure id="shapetree-description-set-shex">
  <figcaption>ShEx Schema for Shape Tree Description Set</figcaption>  
  <pre class=include-code>
    path: shapetrees-schema.shex
    highlight: turtle
    show: 51-54
  </pre>
</figure>    

Definitions {#definitions}
=====================
Two terms are imported from [[RDF]]:
  * <dfn>triple</dfn> -- an [RDF triple](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
  * <dfn>RDF graph</dfn> -- an [RDF graph](https://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple)
        as defined in [[RDF]].

The following terms are used throughout this specification:
  * <dfn>Client-side Agent</dfn> -- A software component interacting with a server.
        A client-side agent will typically rely on the server for shape tree 
        evaluation and/or validation, but may choose to apply it locally
        as well.
  * <dfn>Container</dfn> -- the generalized notion of a collection of resources;
        implementations of [=shape trees=] <em class="rfc2119">MAY</em> use a
        container implementation such as [[LDP]]
        ([ldp:Container](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-container),
        [ldp:BasicContainer](https://www.w3.org/TR/ldp/#dfn-linked-data-platform-basic-container),
        etc.)
  * <dfn>Ecosystem</dfn> -- a software environment with resources organized in
        some hierarchical grouping that rely on [=shape tree=] concepts to
        better organize and validate structures of data
  * <dfn>Focus Node</dfn> -- a node in an [=RDF graph=].  In
        the context of [=shape trees=], one usage is directing [=shape=] validation
        to the appropriate node in an [=RDF graph=].
  * <dfn>Managed Container</dfn> -- any [=managed resource=] that is a 
        [=container=]. A [=Managed Container=] <em class="rfc2119">MAY</em>
        be an [=Instance Root=] or hierarchically nested within the
        resource hierarchy.
  * <dfn>Non-RDF Source</dfn> -- the generalized notion of document not
        containing linked-data triples; this may include
        plain text or binary data.
  * <dfn>Resource</dfn> -- the generalized notion of document containing linked-data;
        implementations of [=shape trees=] may use a resource implementation such
        as [[LDP]] (ldp:Resource, etc.)
  * <dfn>Server-side Agent</dfn> -- A server-side software component.  Server-side
        agents that support shape trees are responsible for data validation and
        maintaining [=shape tree managers=].
  * <dfn>Shape</dfn> -- a schema definition allowing validation of an RDF
        subject.  Example specifications supporting the notion of shapes include 
        [[ShEx]] and [[SHACL]].
  * <dfn>SKOS Graph</dfn> -- an [=RDF graph=] conforming to [[skos-reference]]
        data model.  For purposes of [=shape trees=] a
        [=SKOS Graph=] is used to describe a [=shape tree=] in
        human-readable terms.
  * <dfn>Unmanaged Resource</dfn> -- any [=resource=] which does not have an associated
        [=shape tree=].

  <pre class="biblio">
  {
    "ldp": {
      "href": "https://www.w3.org/TR/ldp/",
      "title": "Linked Data Platform 1.0",
      "authors": [
        "Steve Speicher",
        "John Arwe",
        "Ashok Malhotra"
      ]
    },
    "solid": {
          "href": "https://solidproject.org/TR/protocol",
          "title": "Solid Protocol",
          "authors": [
            "Sarven Capasdisli",
            "Tim Berners-Lee",
            "Kjetil Kjernsmo",
            "Justin Bingham",
            "Ruben Verborgh",
            "Dmitri Zagidulin"]
    },
    "rdf": {
          "href": "https://www.w3.org/TR/rdf11-concepts",
          "title": "RDF 1.1 Concepts and Abstract Syntax",
          "authors": [
            "Richard Cyganiak",
            "David Wood",
            "Markus Lanthaler"
          ]
        },
    "shex": {
      "href": "http://shex.io/shex-semantics/index.html",
      "title": "Shape Expressions Language 2.1",
      "authors": [
        "Eric Prud'hommeaux",
        "Iovka Boneva",
        "Jose Emilio Labra Gayo",
        "Gregg Kellogg"
      ]
    },
    "shexpath": {
      "href": "https://shexspec.github.io/spec/ShExPath",
      "title": "Shape Expressions ShExPath Language",
      "authors": [
        "Eric Prud'hommeaux"
      ]
    }
  }
  </pre>
